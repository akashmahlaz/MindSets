Chat Messaging
/
Docs
/
React Native
React Native Introduction
This section will help you to build any type of chat or messaging experience for a react-native application. There are two important building blocks for react-native integration, we have made them available as npm packages:

Chat API client - this is the interface between Chat rest APIs and your chat components, built using plain javascript. It makes it very easy to communicate with chat APIs e.g., sending a message, connecting to chat, creating channels etc.

Source - https://github.com/GetStream/stream-chat-js

npm - https://www.npmjs.com/package/stream-chat

React Native Component SDK - This provides ready-made UI components that can simply be plugged into your app without building your own UI components. We provide two separate packages to support both react-native and Expo. Both packages rely on the JS client under the hood.

React Native SDK - https://github.com/GetStream/stream-chat-react-native#native-package

Expo SDK - https://github.com/GetStream/stream-chat-react-native#expo-package

We recommend you use one of our component SDKs, react-native or expo, depending on your stack. Chat applications have a lot of moving parts and the Chat Component SDK handles all the stateful chat logic for you to make integration easy. Furthermore, the components offered are highly customisable allowing you to seamlessly incorporate your chat application into your existing application experience. That being said, for various reasons you may choose to build all of your chat UI components yourself, in which case you can simply use the Chat API client and not the Chat Component SDK.

Before reviewing the Chat API docs, we recommend having a look at the tutorials and sample apps.

Getting Started
This guide quickly brings you up to speed on using Stream’s Chat API before you move on and get started. The API is flexible and allows you to build any type of chat or messaging application.

The Stream Chat API client is available as an npm package and also available via yarn.


Bash

# using npm
npm install stream-chat
# using yarn
yarn add stream-chat
After installing the package, import the StreamChat module into your project, and you’re ready to go:


JavaScript

import { StreamChat } from "stream-chat";
// or
const StreamChat = require("stream-chat").StreamChat;
Chat Client
Let’s get started by initialising the client and setting the current user:


JavaScript

const client = StreamChat.getInstance("{{ api_key }}");
// you can still use new StreamChat("api_key");
// Connect user to chat. This establishes a websocket connection between client and server.
await client.connectUser(
  {
    id: "jlahey",
    name: "Jim Lahey",
    image: "https://i.imgur.com/fR9Jz14.png",
  },
  "{{ chat_user_token }}",
);
// To disconnect a user
await client.disconnect();
The above snippet is for an in-browser or mobile integration. Server-side API calls are a little different, but this is covered in detail server side client documentation.

NOTE : Usage of StreamChat.getInstance() available since stream-chat-js@2.12.0. This new Singleton pattern allows you to instantiate a unique StreamChat client, i.e create a StreamChat instance and retrieve it wherever you need it on your app to perform API calls. After calling it once, any following getInstance( call will return the initial StreamChat instance. This will prevent you from accidentally creating multiple StreamChat instances, opening multiple WebSockets, and driving up your concurrent connections unnecessarily.

This new Chat client version is backward compatible. That means users can continue using new StreamChat() if they use an older version of the library or for any other reason.

Channels
Let’s continue by initialising your first channel. A channel contains messages, a list of people that are watching the channel, and optionally a list of members (for private conversations). The example below shows how to set up a channel to support chat for a group conversation:


JavaScript

// Create a channel using your own id for that channel.
const channel = client.channel('messaging', 'travel', {
  name: 'Awesome channel about traveling',
});
// OR create a channel by providing list of members for that channel.
// In this case, id will be auto-generated on backend side
const channel = client.channel('messaging', {
   members: ['vishal', 'neil']
  name: 'Awesome channel about traveling',
});
// fetch the channel state, subscribe to future updates
const state = await channel.watch();
As shown in code-snippet above, you can initialise a channel either by providing

ID for channel

OR list of members for channel. In this case, id will be auto-generated on backend for the channel. Please note that, you can’t add or remove members from channel created using members list .

The channel type controls the settings we’re using for this channel.

There are 5 default types of channels:

livestream
messaging
team
gaming
commerce
These five options above provide you with sensible defaults for those use cases. You can also define custom channel types if Stream Chat defaults don’t work for your use-case.

The third argument is an object containing the channel data. You can add as many custom fields as you would like as long as the total size of the object is less than 5KB.

Please read more about channel operations at Channel docs.

Messages
Now that we have the channel set up, let’s send our first chat message:


JavaScript

const text = "I’m mowing the air Randy, I’m mowing the air.";
const response = await channel.sendMessage({
  text,
  customField: "123",
});
Similar to users and channels, the sendMessage method allows you to add custom fields. When you send a message to a channel, Stream Chat automatically broadcasts to all the people that are watching this channel and updates in real-time. You can also add attachments to the message, please check our Messages docs for details.

Events
This is how you can listen to events on the client-side and update the UI for a channel dynamically:


JavaScript

// Listener for specific event on client
chatClient.on("user.presence.changed", (event) => {
  console.log("online presence changed for user - ", event.user);
});
// Listener for all events on client
chatClient.on((event) => {
  console.log("Received an event on client - ", event);
});
// Channel specific events
channel.on("message.new", (event) => {
  console.log("received a new message", event.message.text);
  console.log(
    `Now have ${channel.state.messages.length} stored in local state`,
  );
});
channel.on((event) => {
  console.log("received a new event", event);
});
You can receive the event and access the full channel state via channel.state .

Please read more about events at Event docs.

Conclusion
Now that you have basic understanding of the building blocks of our chat API, you can move on to react-native integration. Following resources should help you get started:

React native chat tutorial

Getting Started Guide

We would also recommend you to take a deep dive into our Chat API, by following next steps in navigation on left side.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Next
Tokens & Authentication
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Tokens & Authentication
Tokens & Authentication
Authentication vs Authorization
Stream uses JWT (JSON Web Tokens) to authenticate chat users, enabling them to login. Knowing whether a user is authorized to perform certain actions is managed separately via a role based permissions system.

The exception is Anonymous and Guest users who require no authentication to login.

Token Providers
A concept we will refer to throughout the docs is a Token Provider. At a high level, the Token Provider is an endpoint on your server that can perform the following sequence of tasks:

Receive information about a user from the front end.

Validate that user information against your system.

Provide a User-ID corresponding to that user to the server client’s token creation method.

Return that token to the front end.

User Tokens can only be safely generated from a server. This means you will need to implement a Token Provider prior to deploying your application to production. To conduct development before implementing a Token Provider, you will need to disable token authentication.

Generating Tokens
You can generate tokens on the server by creating a Server Client and then using the Create Token method.

If generating a token to use client side, the token must include the userID claim in the token payload, where as server tokens do not. When using the create token method, pass the user_ID parameter to generate a client-side token.


Python

Ruby

PHP

Go

C#

Node

Java

Unity

# pip install stream-chat
import stream_chat
server_client = stream_chat.StreamChat(
  api_key="{{ api_key }}", api_secret="{{ api_secret }}"
)
token = server_client.create_token("john")
Setting Automatic Token Expiration
By default, user tokens are valid indefinitely. You can set an expiration to tokens by passing it as the second parameter. The expiration should contain the number of seconds since Unix epoch (00:00:00 UTC on 1 January 1970).


JavaScript

Python

Ruby

PHP

Java

Go

Swift

C#

Dart

Unreal

Unity

// creates a token that expires in 1 hour using moment.js
const timestamp = Number(moment().add("1h").format("X"));
const token1 = client.createToken("john", timestamp);
// the same can be done with plain javascript
const token2 = client.createToken(
  "john",
  Math.floor(Date.now() / 1000) + 60 * 60,
);
Manual Token Expiration
Token Revocation is a way to manually expire tokens for a single user or for many users by setting a revoke_tokens_issued_before time, and any tokens issued before this will be considered expired and will fail to authenticate. This can be reversed by setting the field to null.

Token Revocation by User
You can revoke all tokens that belong to certain user or list of users


JavaScript

Python

Go

PHP

Ruby

C#

Java

Unity

await client.revokeUserToken("user-id", revokeDate);
await client.revokeUsersToken(["user1-id", "user2-id"], revokeDate);
Note: Your tokens must include the iat (issued at time) claim, which will be compared to the time in the revoke_tokens_issued_before field to determine whether the token is valid or expired. Tokens which have no iat will be considered invalid.

Undoing the revoke
To undo user-level token revocation, you can simply set revocation date to null:


JavaScript

Python

Go

PHP

Ruby

C#

Java

Unity

await client.revokeUserToken("user-id", null);
await client.revokeUsersToken(["user1-id", "user2-id"], null);
Token Revocation by Application
It is possible to revoke tokens for all users of an application. This should be used with caution as it will expire every user’s token, regardless of whether the token has an iat claim


JavaScript

Python

Go

PHP

Ruby

C#

Java

Unity

await client.revokeTokens(revokeDate);
// you can pass Date or ISOstring as value here
Undoing the revoke
To undo app-level token revocation, you can simply set revocation date to null:


JavaScript

Python

Go

PHP

Ruby

C#

Java

Unity

await client.revokeTokens(null);
Adding iat claim to token
By default, user tokens generated through the createToken function do not contain information about time of issue. You can change that by passing the issue date as the third parameter while creating tokens. This is a security best practice, as it enables revoking tokens


JavaScript

Python

Go

PHP

Ruby

C#

Java

Unity

client.createToken("user-id", expireTime, issuedAt);
// issuedAt should be unix timestamp
// issuedAt = Math.floor(Date.now() / 1000)
Developer Tokens
For development applications, it is possible to disable token authentication and use client-side generated tokens or a manually generated static token. Disabling auth checks is not suitable for a production application and should only be done for proofs-of-concept and applications in the early development stage. To enable development tokens, you need to change your application configuration.

On the Dashboard:

Select the App you want to enable developer tokens on

Click Appname to enter the Chat Overview

Scroll to the Authenticationsection

Toggle Disable Auth Checks

Click Save

This disables the authentication check, but does not remove the requirement to send a token. Send either a client generated development token, or manually create one and hard code it into your application.


Kotlin

JavaScript

Java

Swift

Dart

Unreal

Unity

await client.connectUser(
  {
    id: "john",
    name: "John Doe",
    image: "https://getstream.io/random_svg/?name=John",
  },
  client.devToken("john"),
);
The above code used the connectUser call. The connectUser call is the most convenient option when your app has authenticated users. Alternatively, you can use setGuestUser if you want to allow users to chat with a guest account or the connectAnonymousUser if you want to allow anonymous users to watch the chat.

Manually Generating Tokens
You can generate a token manually using the JWT generator.

Your Secret
User ID

Set Expiration?
Please enter a Secret and Stream User ID
If you need to test your app before you have a Token Provider and you don’t want to enable developer tokens, you can hardcode tokens from this generator into your app for testing.

How to Refresh Expired Tokens
If you’re using tokens with an expiration date you’ll want to update tokens as soon as a token exception occurs. Our React, RN, iOS, Android and Flutter libraries have built-in support for this.

Here is the regular flow to handle tokens with expiration with a token provider:

Chat is initialized using the API Key and the token provider

The Chat client will use the token provider to fetch the token when connectUser is called

When the token expires, the API will return a specific Authentication error code

The client will pause API requests and use the token provider to obtain a fresh token

The token provider returns a new token (ie. from your backend)

Chat client replaces the old token with the new one and use it for all waiting and future API calls

A token provider is a function or class that you implement and that is responsible for requesting a new token from your own login infrastructure.

The most common token provider implementation does an HTTP call to your backend with the ID of the user as well as a valid session id or secret needed to authenticate them.


Kotlin

Java

Swift

JavaScript

Unity

const client = new StreamChat("api_key");
const userID = "vishal";
client.connectUser({ id: userID }, async () => {
  // make a request to your own backend to get the token
  const response = await httpBackend.post("/chat-token/", { userID });
  return response.token;
});
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
React Native Introduction
Next
Initialization & Users
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Initialization & Users
Initialization & Users
The code below creates a chat client instance for interacting with Stream APIs. Additional options, such as API base URL, can be configured when creating the instance.


Kotlin

JavaScript

Swift

Dart

Unreal

Java

Unity

import { StreamChat } from "stream-chat";
// client-side you initialize the Chat client with your API key
const chatClient = StreamChat.getInstance("{{ api_key }}", {
  timeout: 6000,
});
Connecting the User
Once initialized, you must specify the current user with connectUser :


Kotlin

JavaScript

Swift

Dart

Unreal

Java

Unity

await chatClient.connectUser(
  {
    id: "john",
    name: "John Doe",
    image: "https://getstream.io/random_svg/?name=John",
  },
  "{{ chat_user_token }}",
);
Note how we are waiting for the connectUser API call to be completed before moving forward. You should always make sure to have the user set before making any more calls. All SDKs make this very easy and wait or queue requests until then.

Connect User Parameters
name	type	description	default	optional
user	object	The user object. Must have an id field. User Ids can only contain characters a-z, 0-9, and special characters @ _ and - It can have as many custom fields as you want, as long as the total size of the object is less than 5KB		
userToken	string	The user authentication token. See Tokens & Authentication for details	default	
WebSocket Connections
The connectUser (or SDK equivalent) function performs several operations when used. Please note that this method should never be used server-side .

Creates a new user if the user_id is not already registered with the application, incrementing the monthly active users

Updates the user in the application (will add/modify existing fields but will not overwrite/delete previously set fields unless the key is used)

Opens a WebSocket connection and increments the Concurrent Connections for the application

The React-native, iOS, Android, and Flutter SDK’s handle WebSocket disconnection logic, but if a manual disconnect is required in your application, then there are the following options


Kotlin

JavaScript

Swift

Dart

Unreal

Java

Unity

await chatClient.disconnectUser();
XHR Fallback
Most browsers support WebSocket connections as an efficient mode of real-time data transfer. However, sometimes the connection cannot be established due to network or a corporate firewall. In such cases, the client will establish or switch to XHR fallback mechanisms and gently poll our service to keep the client up-to-date.

The fallback mechanism can be enabled with the flag enableWSFallback


JavaScript

const chatClient = StreamChat.getInstance(‘apiKey’, { enableWSFallBack: true });
Privacy Settings
Additionally, when connecting the user, you can include the privacy_settings as part of the user object.


Kotlin

JavaScript

Swift

Dart

await chatClient.connectUser(
  {
    id: "john",
    name: "John Doe",
    image: "https://getstream.io/random_svg/?name=John",
    privacy_settings: {
      typing_indicators: {
        enabled: false,
      },
      read_receipts: {
        enabled: false,
      },
    },
  },
  "{{ chat_user_token }}",
);
Let’s have a closer look on the parameters:

name	type	description	default	optional
typing_indicators	object	if enabled is set to false, then typing.start and typing.stop events will be ignored for this user and these events will not be sent to others	enabled: true	✓
read_receipts	object	If enabled is set to false, then the read_state of this user will not be exposed to others. Additionally, read_state related events will not be delivered to others when this user reads messages.	enabled: true	✓
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Tokens & Authentication
Next
Managing Users
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Managing Users
Managing Users
Stream Users require only an id to be created. Users can be created with role of user or admin. The role will be set to user if a value is not provided in the request. There are additional properties you can provide to further describe your users.

If you wish to have users join a chat before they have created an account, check out our Anonymous User support

Client-side User Creation
Stream Chat exposes a connectUser method that automatically creates and updates the user. Please note that the connectUser call has some limitations:

For example, if you’re looking to sync your user base, you’ll want to use the upsertUsers function server-side and send users in bulk.

Server-side User Updates (Batch)
The upsertUsers method creates or updates users, and accepts batch of users in the form of an array of user objects. Any user present in the payload will have its data replaced with the new version. (see below for partial updates) You can send up to 100 users per API request in both upsertUsers and partialUpdateUser .

For example, a client authenticated as a user with permission to create new users or using serverside authentication can create or update a new user:


JavaScript

Python

Go

C#

Dart

Node

Ruby

Java

Unreal

Unity

const updateResponse = await chatClient.upsertUser({
  id: userID,
  role: "admin",
  book: "dune",
});
// user object is now {id: userID, role: 'admin', book: 'dune'}
The upsertUser (server-side) method has permission to make a user an admin; however, the connectUser (client-side) method does not have permission. This is because the connectUser method is called client-side and it is unsecure to edit user permissions in the front-end.

And for a batch of users, simply add additional entries (up to 100) into the array you pass to upsertUsers :


Node

Python

Go

C#

Ruby

Java

Unity

const updateResponse = await serverClient.upsertUsers([
  { id: userID1, role: "admin", book: "dune" },
  { id: userID2, role: "user", book: "1984" },
  { id: userID3, role: "admin", book: "Fahrenheit 451" },
]);
// each user object is updated accordingly
If any user in a batch of users contains an error, the entire batch will fail, and the first error encountered will be returned.

Server-side Partial Update (Batch)
If you need to update a subset of properties for a user(s), you can use a partial update method. Both set and unset parameters can be provided to add, modify, or remove attributes to or from the target user(s). The set and unset parameters can be used separately or combined.

Please see below for an example:


JavaScript

Python

Ruby

PHP

Java

Go

Swift

C#

// make partial update call for userID
// it set's user.role to "admin", sets user.field = {'text': 'value'}
// and user.field2.subfield = 'test'.
//
// NOTE:
// changing role is available only for server-side auth.
// field name should not contain dots or spaces, as dot is used as path separator.
const update = {
  id: "userID",
  set: {
    role: "admin",
    field: {
      text: "value",
    },
    "field2.subfield": "test",
  },
  unset: ["field.unset"],
};
// response will contain user object with updated users info
const response = await client.partialUpdateUser(update);
// partial update for multiple users
const updates = [
  {
    id: "userID",
    set: {
      field: "value",
    },
  },
  {
    id: "userID2",
    unset: ["field.value"],
  },
];
// response will contain object {userID => user} with updated users info
const response = await client.partialUpdateUsers(updates);
Partial updates support batch requests, similar to the upsertUser endpoint.

Unique Usernames
Clients can set a username, by setting the name custom field. The field is optional and by default has no uniqueness constraints applied to it, however this is configurable by setting the enforce_unique_username to either app, team or no.

When checking for uniqueness, the name is normalized, by removing any white-space or other special characters, and finally transforming it to lowercase. So “John Doe” is considered a duplicate of “john doe”, “john.doe”, etc.


JavaScript

Ruby

Python

Java

C#

Go

PHP

Unity

// Enable uniqueness constraints on App level
await client.updateAppSettings({
  enforce_unique_usernames: "app",
});
Enabling this setting will only enforce the constraint going forward and will not try to validate existing usernames.

When this setting is set to app, attempts to create or update a user with an existing name in this app, will fail with duplicate username error.


JavaScript

Ruby

Python

Java

C#

Go

PHP

Unity

// Enable uniqueness constraints on Team level
await client.updateAppSettings({
  enforce_unique_usernames: "team",
});
When set to team, attempts to create or update a user with an existing name will fail only if the name already exists within a common team.

Deactivate a User
To deactivate a user, Stream Chat exposes a deactivateUser method. This method can only be called server-side due to security concerns, so please keep this in mind when attempting to make the call.

Deactivated users cannot:

Connect to Stream Chat

Send or receive messages

(deactivated users can be reactivated, see below)

Below is an example of how to execute the call to deactivateUser :

The mark_messages_deleted parameter is optional. This parameter will delete all messages associated with the user. If you would like to keep message history, ensure that mark_messages_deleted is set to false. To remove all messages related to the user, set the value to true .


JavaScript

Python

Ruby

PHP

Go

C#

Java

Unity

const deactivate = await client.deactivateUser(userID);
const deactivate = await client.deactivateUser(userID, {
  mark_messages_deleted: true,
  created_by_id: "joe",
});
The response will contain an object with the user ID that was deactivated. Further, the user will no longer be able to connect to Stream Chat as an error will be thrown.

To reinstate the user as active, use the reactivateUser method by passing the users ID as a parameter:


JavaScript

Python

Ruby

PHP

Go

C#

Java

Unity

const reactivate = await client.reactivateUser(userID);
const reactivate = await client.reactivateUser(userID, {
  restore_messages: true,
  name: "I am back",
  created_by_id: "joe",
});
Deactivate many Users
Many users (up to 100) can be deactivated and reactivated with only one call. The operation will be ran asynchronously, the response contains a task_id which can be polled using the getTask endpoint to check the status of the operation.


JavaScript

Unity

// Deactivate many users in one call
let resp = await serverClient.deactivateUsers([userIDs, ...], {
   created_by_id: userID, // optional: define who deactivated the users
   mark_messages_deleted: true // optional: the messages will be marked as deleted
})
resp = await serverClient.reactivateUsers([userIDs, ...], {
   created_by_id: userID, // optional: define who reactivated the users
   restore_messages: true // optional: the messages will be restored if they were deleted
})
// both resp contains a task_id to check the status of the operation
Delete a User
While it is usually safer for data retention to deactivate a user, some use cases require completely deleting a user and their data. Regional or platform regulations such as the GDPR right to deletion or Apple App Store’s data collection and storage guidelines are two examples of regulations that require this.

Use the deleteUser method to remove user data. This method must be called server-side only for security reasons.

Soft Delete: The user_id cannot be reused, but it can be restored. Hard Delete: The user_id is permanently removed and can be reused.

Below is an example of how to execute the call to deleteUser :


JavaScript

Python

Ruby

PHP

Go

C#

Java

Unity

const destroy = await client.deleteUser(userID, {
  mark_messages_deleted: false,
});
The mark_messages_deleted parameter is optional. This parameter will delete all messages associated with the user. If you would like to keep message history, ensure that mark_messages_deleted is set to false. To remove all messages related to the user, set the value to true .

Hard Delete a User
To perform a “hard delete” on the user, you must set mark_messages_deleted to true and provide an additional parameter called hard_delete with the value set to true. This method will delete all messages, reactions, and any other associated data with the user. Another option is delete_conversation_channels, if set true the deleted user is removed from all one-to-one channels.


JavaScript

PHP

Go

C#

Python

Ruby

Java

Unity

const destroy = await client.deleteUser("user_id", {
  delete_conversation_channels: true,
  mark_messages_deleted: true,
  hard_delete: true,
});
deleteUser with hard_delete: true does not perform full hard delete of the user, but does “pruning” delete instead. Please use deleteUsers endpoint to perform true hard delete. See “Deleting Many Users” section for more deletion options

After deleting or hard deleting a user, the user will no longer be able to:

Connect to Stream Chat

Send or receive messages

Be displayed when querying users

Have messages stored in Stream Chat (depending on whether or not mark_messages_deleted is set to true or false )

These are the request parameters which determine what user data is deleted:

name	type	description	default	optional
user_ids	array	List of users who will be deleted	-	
mark_messages_deleted	boolean	Delete all of the users messages too	-	✓
delete_conversation_channels	boolean	Delete all 1:1 channels with this user	-	✓
hard_delete	boolean	By default, messages are soft deleted, which means they are removed from client but are still available via server-side export functions. Hard delete will remove data from everywhere on the server		✓
new_channel_owner_id	string	Channels owned by hard-deleted users will be transferred to this userID.	-	✓
Deleting Many Users
You can delete up to 100 users and optionally all of their channels and messages using this method. First the users are marked deleted synchronously so the user will not be directly visible in the API. Then the process deletes the user and related objects asynchronously by scheduling a task to be handles by the task worker.

This method can only be called server-side due to security concerns. This is supported on the following SDK versions (or higher):

Javascript 4.3.0, Python 3.14.0, Ruby 2.12.0, PHP 2.6.0, Go 3.13.0, Java 1.4.0 and .NET 0.22.0

JavaScript

Python

Go

PHP

Ruby

Java

C#

Unity

let response = await serverClient.deleteUsers(['userID1', 'userID2'], {
  user: 'soft',
  messages: 'hard',
});
response = await serverClient.getTask(response['task_id']);
if(response['status] === 'completed') {
  // success!
}
The deleteUsers response contain a task_id which can be polled using the getTask endpoint to check the status of the deletions.

Alternatively, you can listen to the user.deleted event to receive a notification when the deletion is complete for each user. This avoids the need to poll the getTask endpoint.

These are the request parameters which determine what user data is deleted:

name	type	description	default	optional
user_ids	array	List of users who will be deleted	-	
user	enum (soft, pruning, hard)	Soft: marks user as deleted and retains all user data. Pruning: marks user as deleted and nullifies user information. Hard: deletes user completely - this requires hard option for messages and conversation as well.	-	✓
conversations	enum (soft, hard)	Soft: marks all conversation channels as deleted (same effect as Delete Channels with ‘hard’ option disabled). Hard: deletes channel and all its data completely including messages (same effect as Delete Channels with ‘hard’ option enabled).		✓
messages	enum (soft, pruning, hard)	Soft: marks all user messages as deleted without removing any related message data. Pruning: marks all user messages as deleted, nullifies message information and removes some message data such as reactions and flags. Hard: deletes messages completely with all related information.	-	✓
new_channel_owner_id	string	Channels owned by hard-deleted users will be transferred to this userID.	-	✓
When deleting a user, if you wish to transfer ownership of their channels to another user, provide that user’s ID in the new_channel_owner_id field. Otherwise, the channel owner will be updated to a system generated ID like delete-user-8219f6578a7395g

Restoring deleted users
If users are soft (only) deleted they can be restored using server side client. However, only user’s metadata is restored, membership, messages etc… can’t be put back.

You can restore up to 100 users per call:


JavaScript

Python

Unity

await client.restoreUsers(["userID1", "userID2"]);
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Initialization & Users
Next
Authless Users
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Authless Users
Authless Users
Stream Chat also lets you give unauthenticated users with access to a limited subset of Stream’s capabilities. This is done by using either Guest or Anonymous users.

These two user types are ideal for use cases where users either need to be able to see chat activity prior to authenticating or in scenarios where the additional friction of creating a user account might be unnecessary for a user.

Guest Users
Guest sessions can be created client-side and do not require any server-side authentication. Support and livestreams are common use cases for guests users because really often you want a visitor to be able to use chat on your application without (or before) they have a regular user account.

Guest users are not available to application using multi-tenancy (teams).

Guest users are counted towards your MAU usage.

Guest users have a limited set of permissions. You can read more about how to configure permissions here. You can create a guest user session by using setGuestUser instead of connectUser .

You can generate a guest user in a front end client by using the following code:


Kotlin

JavaScript

Swift

Dart

Unreal

Java

Unity

await client.setGuestUser({ id: "tommaso" });
The user object schema is the same as the one described in the Setting the user portion of the docs.

Creation of guest users can be disabled for your application in the dashboard.

Anonymous Users
If a user is not logged in, you can call the connectAnonymousUser method. While you’re anonymous, you can’t do much by default, but for the livestream channel type, you’re still allowed to read the chat conversation.


Kotlin

JavaScript

Swift

Dart

Unreal

Java

Unity

const connectResponse = await client.connectAnonymousUser();
console.log(connectResponse.me);
When you connect to chat using anonymously you receive a special user back with the following data:


JSON

{
  "id": "!anon",
  "role": "anonymous",
  "roles": [],
  "created_at": "0001-01-01T00:00:00Z",
  "updated_at": "0001-01-01T00:00:00Z",
  "last_active": "2020-11-02T18:36:01.125136Z",
  "banned": false,
  "online": true,
  "invisible": false,
  "devices": [],
  "mutes": [],
  "channel_mutes": [],
  "unread_count": 0,
  "total_unread_count": 0,
  "unread_channels": 0,
  "language": ""
}
Anonymous users are not counted toward your MAU number and only have an impact on the number of concurrent connected clients.

Anonymous users are not allowed to perform any write operations

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Managing Users
Next
Logging Out
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Logging Out
Logging Out
User can be logged out by disconnecting the user. After disconnection, call connect user for logging in with another user.


Kotlin

JavaScript

Swift

Dart

Unreal

Java

Unity

await client.disconnectUser();
await client.connectUser(
  {
    id: "jack",
    name: "Jack Doe",
  },
  "{{ chat_user_token }}",
);
Disable Push Notifications
Additionally, you’ll want to stop the user from receiving further push notifications by unregistering their device.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Authless Users
Next
Querying Users
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Querying Users
Querying Users
The Query Users method allows you to search for users and see if they are online/offline. The example below shows how you can retrieve the details for 3 users in one API call:


Kotlin

JavaScript

Java

Swift

PHP

Dart

Unreal

C#

Python

Unity

Ruby

const response = await client.queryUsers({
  id: { $in: ["john", "jack", "jessie"] },
});

Kotlin

JavaScript

Swift

PHP

Dart

Unreal

C#

Python

Unity

Ruby

const response = await client.queryUsers(
  { id: { $in: ["jessica"] } },
  { last_active: -1 },
  { presence: true },
);
Another option is to query for banned users. This can be done with the following code snippet:


Kotlin

JavaScript

PHP

Swift

Java

Dart

Unreal

C#

Python

Unity

Ruby

const banned = await client.queryUsers({ id: "jessica", banned: true });
An object with an array of users will be returned.

Please be aware that this query will return users banned across the entire app, not at a channel level.

All filters use a Mongoose style syntax; however, we do not run MongoDB on the backend, so you can only use a subset of queries that are normally available within Mongoose. The supported queries are described below.

You can filter and sort on the custom fields you’ve set for your user, the user id, and when the user was last active.

Supported queries
The options for the queryUser method are include_deactivated_users, presence, limit, and offset. If presence is true this makes sure you receive the user.presence.changed event when a user goes online or offline.

name	type	description	default	optional
filter_conditions	objects	Conditions to use to filter the users	-	
presence	boolean	Get updates when the user goes offline/online	true	✓
sort	object or array of objects	The sorting used for the users matching the filters. Sorting is based on field and direction, and multiple sorting options can be provided. Direction can be ascending (1) or descending (-1).	[{created_at: -1}, {id: -1}]	✓
limit	integer	Number of users to return	30	✓
offset	integer	Offset for pagination	0	✓
id_gt	string	ID-based pagination. Return IDs greater than this ID. If this is not empty, the default sort order will be [{id: -1}].	-	✓
id_gte	string	ID-based pagination. Return IDs greater than or equal to this ID. If this is not empty, the default sort order will be [{id: -1}].	-	✓
id_lt	string	ID-based pagination. Return IDs less than this ID. If this is not empty, the default sort order will be [{id: -1}].	-	✓
id_lte	string	ID-based pagination. Return IDs less than or equal to this ID. If this is not empty, the default sort order will be [{id: -1}].	-	✓
include_deactivated_users	boolean	Include deactivated users in the response	-	✓
You can subscribe to presence status of at most 30 users using this method.

Note - The offset limit is set to 1000.

Filter conditions

Name	Type	Description	allowed operators
id	string	ID of the user	$eq, $gt, $gte, $lt, $lte, $in, $autocomplete
role	string	role of the user	$eq, $gt, $gte, $lt, $lte, $in
banned	boolean	users that have been banned	$eq
shadow_banned	boolean	users that have been shadow banned	$eq
created_at	string, must be formatted as an RFC3339 timestamp	created time of the user	$eq, $gt, $gte, $lt, $lte, $in
updated_at	string, must be formatted as an RFC3339 timestamp	updated time of the user	$eq, $gt, $gte, $lt, $lte, $in
last_active	string, must be formatted as an RFC3339 timestamp	time when the user was last active	$eq, $gt, $gte, $lt, $lte, $in, $exists
teams	string	teams that the user belongs to	$eq, $contains
name	string	name property of the user	$eq, $autocomplete
username	string	username property of the user	$eq, $autocomplete
Querying Using the $autocomplete Operator
You can autocomplete the results of your user query by username and/or ID.

1. By Name
If you want to return all users whose field 'name' has a value that includes 'ro', you could do so with the following:


Kotlin

JavaScript

PHP

Swift

Java

Dart

Unreal

C#

Python

Ruby

Unity

const response = await serverClient.queryUsers({
  name: { $autocomplete: "ro" },
});
This would return an array of any matching users, such as:


JSON

[
  {
    "id": "userID",
    "name": "Curiosity Rover"
  },
  {
    "id": "userID2",
    "name": "Roxy"
  },
  {
    "id": "userID3",
    "name": "Roxanne"
  }
]
2. By ID

Kotlin

JavaScript

PHP

Swift

Java

Dart

Unreal

C#

Python

Ruby

Unity

const response = await client.queryUsers({ id: { $autocomplete: "USER_ID" } });
Querying users that have never connected
You can use the last_active field in combination with the $exists operator to query users that have never connected. You can also use "$exists": true to filter users that have connected at least once.


JavaScript

Python

const response = await client.queryUsers({
  id: { $in: [activeUser, neverActiveUser] },
  last_active: { $exists: false },
});
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Logging Out
Next
Stream API and client integration
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Stream API and client integration
Stream API and client integration
How do the Chat Client, Server, & Stream API communicate with each other?
This article will cover how the Stream Chat Client, Server, and Stream API all communicate with each other. If you have any further questions, please reach out to support at https://getstream.io/contact/support/.

The Stream Chat client runs on a user’s local device, it is also what opens up a websocket/concurrent connection. The server is spun up on the Stream customer’s end. The Stream API is self-explanatory and interacts with both the client and server.

The following code example will show you how a user generates tokens from their server and then connects to the Stream API. The below diagram gives a visual representation of this process.


1. Server-side
Once you’ve created your App, you can access your App Secret and Key in the Stream Dashboard. These credentials enable server-side access. Note: With server-side access, a trusted user can bypass all client-side permissions, so it’s important to never expose the application secret client-side.

Now, we want our chat client to connect to the Stream API, but first, we need to generate a token (JWT). Tokens are generated server-side. Beyond generating and returning tokens, server-side Stream code may also include creating channels, promoting users to admins, or taking moderation measures such as banning or removing users from the app.

The below code shows how to create a token using the JS SDK:


JavaScript

const chatClient = new StreamChat(appKEY, secret);
const user_id = "bob";
const token = chatClient.createToken(user_id);
The below code shows how to use a basic method for generating a token from a client-side POST request:


JavaScript

Unity

const chatClient = new StreamChat(appKEY, secret);
server.post(“/token”, async (req, res) => {
 const { user_id } = req.body;
 try {
  const token = await chatClient.createToken(user_id.toString());
  res.status(200).json({
   payload: token,
  });
 } catch (error) {
  console.log(error);
  res.sendStatus(400);
 }
});
2. Client-side
Once the client has a token, it can connect directly to the Stream API with the connectUser() method. Here are some important best practices on how to use this method.


JavaScript

Unity

const set = await chatClient.connectUser({ id: userID }, token);
3. User Authentication & Stream API
Once the user has been authenticated with the connectUser() method, they have access to certain Stream data (e.g. channels, messages, etc.) based on permissions and may continue interacting with our API via the client.

Review
Above, we instantiated the chat client, created the token server-side, and then the user would be authenticated, so they can connect the client to the Stream API. Now the client will continue to interact with the Stream API until it’s disconnected.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Querying Users
Next
Overview
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Overview
Overview
Application level settings allow you to configure settings that impact all the channel types in your app. Our backend SDKs make it easy to change the app settings. You can also change most of these using the CLI or the dashboard. Here’s an example on changing the disable_auth_checks setting:


JavaScript

Python

PHP

Go

Ruby

C#

Java

Unity

// disable auth checks, allows dev token usage
await client.updateAppSettings({
  disable_auth_checks: true,
});
// re-enable auth checks
await client.updateAppSettings({
  disable_auth_checks: false,
});
A full overview of available settings can be found below:

Permissions
The following app settings allow you to control how permissions work for your app:

NAME	DESCRIPTION	DEFAULT
disable_auth_checks	Disabled authentication. Convenient during testing and allows you to use devTokens on the client side. Should not be used in production.	false
disable_permissions_checks	Gives all users full permissions to edit messages, delete them etc. Again not recommended in a production setting, only useful for development.	false
Push
NAME	DESCRIPTION	DEFAULT
apn_config	APN config object. See details.	
firebase_config	Firebase config object. See details.	
huawei_config	Huawei config object. See details.	
xiaomi_config	Xiaomi config object. See details.	
push_config	Global config object. See details.	
CDN
NAME	DESCRIPTION	DEFAULT
cdn_expiration_seconds	CDN URL expiration time. See details.	1209600 (14 days)
Hooks
Custom Action Handler and Before Message Send Webhooks
NAME	DESCRIPTION	DEFAULT
custom_action_handler_url	This webhook reacts to custom /slash commands and actions on those commands/	-
before_message_send_hook_url	This webhook allows you to modify or moderate message content before sending it to the chat for everyone to see	-
Webhooks, SQS, SNS, and pending messages
Webhooks, SQS, SNS, and pending messages async moderation now use the event_hooks array configuration. See the Multi-Event Hooks documentation for complete details.

Moderation & Translation
The following settings allow you to control moderation for your chat:

NAME	DESCRIPTION	DEFAULT
image_moderation_labels	Moderation scores returned from the external image moderation API	-
image_moderation_enabled	If image moderation AI should be turned on	-
enforce_unique_usernames	If Stream should enforce username uniqueness. This prevents people from joining the chat as “elonmusk” while “elonmusk” is presenting.	-
auto_translation_enabled	If Stream should automatically translate messages	-
async_url_enrich_enabled	If url enrichment should be done async. It will trigger message.updated event	-
File Uploads
You can set restrictions on file uploads by including a file_upload_config object. You can set either an inclusive list using allowed_file_extensions and allowed_mime_types or an exclusive list using blocked_file_extensions and blocked_mime_types .

The file_upload_config object accepts the following fields:

NAME	DESCRIPTION	Example	Default
allowed_file_extensions	An array of file types that the user can submit. Files with an extension that does not match the values in this array will be rejected.	[“.tar”, “.png”, “.jpg”]	-
blocked_file_extensions	An array of file types that the user can submit. Files with an extension that does not match the values in this array will be rejected.	[“.tar”, “.png”, “.jpg”]	-
allowed_mime_types	An array of file MIME types that the user can submit. Files with an MIME type that does not match the values in this array will be rejected. Must follow the type/ subtype pattern.	[“text/css”, “text/plain”, “image/png”]	-
blocked_mime_types	An array of file types that the user can submit. Files with an MIME type that does not match the values in this array will be rejected. Must follow the type/ subtype pattern.	[“text/css”, “text/plain”, “image/png”]	-
size_limit	A number that represents the maximum accepted file size in bytes. In case its 0 the default maximum is used.	10485760	0
For example, the following code shows how to block all attempts to upload any files that are not .csv:


JavaScript

Python

PHP

Go

Ruby

C#

Java

Unity

// Only accept .CSV files
await client.updateAppSettings({
  file_upload_config: {
   allowed_file_extensions: [".csv"],
   allowed_mime_types: ["text/csv"]
});
Image Uploads
You can set restrictions on file uploads by including an image_upload_config object. You can set either an inclusive list using allowed_file_extensions and allowed_mime_types or an exclusive list using blocked_file_extensions and blocked_mime_types .

The image_upload_config object accepts the following fields:

NAME	DESCRIPTION	Example	Default
allowed_file_extensions	An array of file types that the user can submit. Files with an extension that does not match the values in this array will be rejected.	[“.gif”, “.png”, “.jpg”]	-
blocked_file_extensions	An array of file types that the user can submit. Files with an extension that does not match the values in this array will be rejected.	[“.tar”, “.tiff”, “.jpg”]	-
allowed_mime_types	An array of file MIME types that the user can submit. Files with an MIME type that does not match the values in this array will be rejected. Must follow the type/ subtype pattern.	[“image/jpeg”, “image/svg+xml”, “image/png”]	-
blocked_mime_types	An array of file types that the user can submit. Files with an MIME type that does not match the values in this array will be rejected. Must follow the type/ subtype pattern.	[“text/css”, “text/plain”, “image/tiff”]	-
size_limit	A number that represents the maximum accepted file size in bytes. In case its 0 the default maximum is used.	10485760	0
For example, the following code shows how to block all attempts to upload any files that are not gif, jpeg, or png files:


JavaScript

Python

PHP

Go

Ruby

C#

Java

Unity

// Only accept gif, jpeg, or png files.
await client.updateAppSettings({
  image_upload_config: {
   allowed_file_extensions: [".gif", ".jpeg", ".png"],
   allowed_mime_types: ["image/gif", "image/jpeg", "image/png"]
});
Stream allowed types for images are: image/bmp, image/gif, image/jpeg, image/png, image/webp, image/heic, image/heic-sequence, image/heif, image/heif-sequence, image/svg+xml. Applications can set a more restrictive list, but would not be allowed to set a less restrictive list.

User’s Average Response Time
The User Average Response Time feature enables users to view the average response time of other users in their public profiles. This metric helps set expectations for communication responsiveness, which is particularly valuable in marketplace applications where prompt responses are important for successful transactions.

Configuration
To enable user response time tracking, set the user_response_time_enabled setting to true:


JavaScript

Python

PHP

Go

Ruby

C#

Java

Unity

// Enable user response time tracking
await client.updateAppSettings({
  user_response_time_enabled: true,
});
Once enabled, the avg_response_time field will be included in user responses and displayed in user profiles.

Use Cases
Marketplace Applications
Buyers can see how quickly sellers typically respond before initiating contact
Marketplaces can highlight responsive sellers with badges or sorting options
Customer support teams can identify and reward highly responsive users
Service Platforms
Service providers can demonstrate their responsiveness to potential clients
Users can select service providers based on communication expectations
Customer Support Applications
Display agent responsiveness to help manage customer expectations
Create internal leaderboards based on response times
How It Works
The system tracks the time between replies in a channel and when they respond
When a user sends a new message that isn’t the first in a channel, the system calculates a new average
This data is then displayed in the user’s public profile or returned in the avg_response_time field
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Stream API and client integration
Next
Multi-region Support
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Multi-region Support
Multi-region Support
Stream’s Chat infrastructure is partially replicated on several regions, allowing developers all around the globe to optimize for network latency by mapping their usage to the region closest to their users. There is support for Chat in US East, EU West, Singapore, Sydney and Mumbai.

Users can now arbitrarily create apps in the location of their choice, without any action or approval needed from our side. Two steps are required to do so :

Dashboard Server Location
For Chat, users will first choose hosting their app in our US East, EU West, Singapore, Sydney or Mumbai server instances.

Once you’ve set the region for your application, it cannot be changed.


Client Location Settings
Stream’s new Edge infrastructure removes the need to specifically set a regional URL. The baseURL is https://chat.stream-io-api.com regardless of region.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Overview
Next
Production & Development Mode
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Production & Development Mode
Production & Development Mode
Stream apps can be configured to be either in development mode or in production mode. You can select which mode your app should be in when you create it in the Stream dashboard, and you can easily switch between modes later on.

When your app is in production mode, certain destructive features in the dashboard are disabled. This prevents you from accidentally deleting user data or disabling mission-critical features.

To switch between modes, log in to the dashboard and find your app. In the options dropdown for that app, click the Edit button. This will open a modal window in which you can choose which mode your app should be in.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Multi-region Support
Next
Auth Settings
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Overview
Overview
Application level settings allow you to configure settings that impact all the channel types in your app. Our backend SDKs make it easy to change the app settings. You can also change most of these using the CLI or the dashboard. Here’s an example on changing the disable_auth_checks setting:


JavaScript

Python

PHP

Go

Ruby

C#

Java

Unity

// disable auth checks, allows dev token usage
await client.updateAppSettings({
  disable_auth_checks: true,
});
// re-enable auth checks
await client.updateAppSettings({
  disable_auth_checks: false,
});
A full overview of available settings can be found below:

Permissions
The following app settings allow you to control how permissions work for your app:

NAME	DESCRIPTION	DEFAULT
disable_auth_checks	Disabled authentication. Convenient during testing and allows you to use devTokens on the client side. Should not be used in production.	false
disable_permissions_checks	Gives all users full permissions to edit messages, delete them etc. Again not recommended in a production setting, only useful for development.	false
Push
NAME	DESCRIPTION	DEFAULT
apn_config	APN config object. See details.	
firebase_config	Firebase config object. See details.	
huawei_config	Huawei config object. See details.	
xiaomi_config	Xiaomi config object. See details.	
push_config	Global config object. See details.	
CDN
NAME	DESCRIPTION	DEFAULT
cdn_expiration_seconds	CDN URL expiration time. See details.	1209600 (14 days)
Hooks
Custom Action Handler and Before Message Send Webhooks
NAME	DESCRIPTION	DEFAULT
custom_action_handler_url	This webhook reacts to custom /slash commands and actions on those commands/	-
before_message_send_hook_url	This webhook allows you to modify or moderate message content before sending it to the chat for everyone to see	-
Webhooks, SQS, SNS, and pending messages
Webhooks, SQS, SNS, and pending messages async moderation now use the event_hooks array configuration. See the Multi-Event Hooks documentation for complete details.

Moderation & Translation
The following settings allow you to control moderation for your chat:

NAME	DESCRIPTION	DEFAULT
image_moderation_labels	Moderation scores returned from the external image moderation API	-
image_moderation_enabled	If image moderation AI should be turned on	-
enforce_unique_usernames	If Stream should enforce username uniqueness. This prevents people from joining the chat as “elonmusk” while “elonmusk” is presenting.	-
auto_translation_enabled	If Stream should automatically translate messages	-
async_url_enrich_enabled	If url enrichment should be done async. It will trigger message.updated event	-
File Uploads
You can set restrictions on file uploads by including a file_upload_config object. You can set either an inclusive list using allowed_file_extensions and allowed_mime_types or an exclusive list using blocked_file_extensions and blocked_mime_types .

The file_upload_config object accepts the following fields:

NAME	DESCRIPTION	Example	Default
allowed_file_extensions	An array of file types that the user can submit. Files with an extension that does not match the values in this array will be rejected.	[“.tar”, “.png”, “.jpg”]	-
blocked_file_extensions	An array of file types that the user can submit. Files with an extension that does not match the values in this array will be rejected.	[“.tar”, “.png”, “.jpg”]	-
allowed_mime_types	An array of file MIME types that the user can submit. Files with an MIME type that does not match the values in this array will be rejected. Must follow the type/ subtype pattern.	[“text/css”, “text/plain”, “image/png”]	-
blocked_mime_types	An array of file types that the user can submit. Files with an MIME type that does not match the values in this array will be rejected. Must follow the type/ subtype pattern.	[“text/css”, “text/plain”, “image/png”]	-
size_limit	A number that represents the maximum accepted file size in bytes. In case its 0 the default maximum is used.	10485760	0
For example, the following code shows how to block all attempts to upload any files that are not .csv:


JavaScript

Python

PHP

Go

Ruby

C#

Java

Unity

// Only accept .CSV files
await client.updateAppSettings({
  file_upload_config: {
   allowed_file_extensions: [".csv"],
   allowed_mime_types: ["text/csv"]
});
Image Uploads
You can set restrictions on file uploads by including an image_upload_config object. You can set either an inclusive list using allowed_file_extensions and allowed_mime_types or an exclusive list using blocked_file_extensions and blocked_mime_types .

The image_upload_config object accepts the following fields:

NAME	DESCRIPTION	Example	Default
allowed_file_extensions	An array of file types that the user can submit. Files with an extension that does not match the values in this array will be rejected.	[“.gif”, “.png”, “.jpg”]	-
blocked_file_extensions	An array of file types that the user can submit. Files with an extension that does not match the values in this array will be rejected.	[“.tar”, “.tiff”, “.jpg”]	-
allowed_mime_types	An array of file MIME types that the user can submit. Files with an MIME type that does not match the values in this array will be rejected. Must follow the type/ subtype pattern.	[“image/jpeg”, “image/svg+xml”, “image/png”]	-
blocked_mime_types	An array of file types that the user can submit. Files with an MIME type that does not match the values in this array will be rejected. Must follow the type/ subtype pattern.	[“text/css”, “text/plain”, “image/tiff”]	-
size_limit	A number that represents the maximum accepted file size in bytes. In case its 0 the default maximum is used.	10485760	0
For example, the following code shows how to block all attempts to upload any files that are not gif, jpeg, or png files:


JavaScript

Python

PHP

Go

Ruby

C#

Java

Unity

// Only accept gif, jpeg, or png files.
await client.updateAppSettings({
  image_upload_config: {
   allowed_file_extensions: [".gif", ".jpeg", ".png"],
   allowed_mime_types: ["image/gif", "image/jpeg", "image/png"]
});
Stream allowed types for images are: image/bmp, image/gif, image/jpeg, image/png, image/webp, image/heic, image/heic-sequence, image/heif, image/heif-sequence, image/svg+xml. Applications can set a more restrictive list, but would not be allowed to set a less restrictive list.

User’s Average Response Time
The User Average Response Time feature enables users to view the average response time of other users in their public profiles. This metric helps set expectations for communication responsiveness, which is particularly valuable in marketplace applications where prompt responses are important for successful transactions.

Configuration
To enable user response time tracking, set the user_response_time_enabled setting to true:


JavaScript

Python

PHP

Go

Ruby

C#

Java

Unity

// Enable user response time tracking
await client.updateAppSettings({
  user_response_time_enabled: true,
});
Once enabled, the avg_response_time field will be included in user responses and displayed in user profiles.

Use Cases
Marketplace Applications
Buyers can see how quickly sellers typically respond before initiating contact
Marketplaces can highlight responsive sellers with badges or sorting options
Customer support teams can identify and reward highly responsive users
Service Platforms
Service providers can demonstrate their responsiveness to potential clients
Users can select service providers based on communication expectations
Customer Support Applications
Display agent responsiveness to help manage customer expectations
Create internal leaderboards based on response times
How It Works
The system tracks the time between replies in a channel and when they respond
When a user sends a new message that isn’t the first in a channel, the system calculates a new average
This data is then displayed in the user’s public profile or returned in the avg_response_time field
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Stream API and client integration
Next
Multi-region Support
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Multi-region Support
Multi-region Support
Stream’s Chat infrastructure is partially replicated on several regions, allowing developers all around the globe to optimize for network latency by mapping their usage to the region closest to their users. There is support for Chat in US East, EU West, Singapore, Sydney and Mumbai.

Users can now arbitrarily create apps in the location of their choice, without any action or approval needed from our side. Two steps are required to do so :

Dashboard Server Location
For Chat, users will first choose hosting their app in our US East, EU West, Singapore, Sydney or Mumbai server instances.

Once you’ve set the region for your application, it cannot be changed.


Client Location Settings
Stream’s new Edge infrastructure removes the need to specifically set a regional URL. The baseURL is https://chat.stream-io-api.com regardless of region.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Overview
Next
Production & Development Mode
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Permissions v2
Permissions v2
Before You Start
Make sure that your application has version 2 of permissions enabled. In order to do that, follow this guide first.

Getting Started
There are multiple important terms to understand when it comes to permission management. Each permission check comes down to three things:

Subject - an actor which attempts to perform certain Action. It could be represented by a User or by a ChannelMember

Resource - an item that Subject attempts to perform an Action against. It could be a Channel, Message, Attachment or another User

Action - the exact action that is being performed. For example CreateChannel, DeleteMessage, AddLinks

The purpose of permission system is to answer a question: is Subject A allowed to perform Action B on Resource C ?

Stream Chat provides several concepts which help to control which actions are available to whom:

Permission - an object which represents actions a subject is allowed to perform

Role - assigned to a User or Channel Member and is used to check their permissions

Grants - the way permissions are assigned to roles, applicable across the entire application, or specific to a single channel type or channel.

Also important to know is permissions checking only happens on the client-side calls. Server-side allows everything so long as a valid API key and secret is provided.

Role Management
To make it easy to get started, all Stream applications come with several roles already built in with permissions to represent the most common use cases. These roles can be customized if needed, and new roles can be created specific for your application

This is the process of assigning a role to users so they can be granted permissions. This represents Subject A in the permissions question. Users will have one role which grants them permissions for the entire application and additionally users can have channel roles which grant permissions for a single channel or for all channels with the same channel type.

By default all users have builtin role user assigned. To change the role of the User, you can use UpdateUser API endpoint:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

await client.partialUpdateUser({
  id: "james_bond",
  set: { role: "special_agent" },
});
Once you add user to the channel, channel_member role will be assigned to user’s membership:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

const result = await channel.addMembers([{ user_id: "james_bond" }]);
console.log(result.members[0].channel_role); // "channel_member"
In order to change channel-level role of the user, you can either add user to the channel with a different role (if the SDK supports it) or update it later by role assignment:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

// Add user to the channel with role set
await channel.addMembers([
  { user_id: "james_bond", channel_role: "channel_moderator" },
]);
// Assign new channel member role
await channel.assignRoles([
  { user_id: "james_bond", channel_role: "channel_member" },
]);
changing channel member roles is not allowed client-side.

Subject

Subject can be represented by User or ChannelMember. ChannelMember subject is used only when user interacts with a channel that they are member of. Both User and ChannelMember have Role and permission system takes both roles into consideration when checking permissions.

Builtin roles
There are some builtin roles in Stream Chat that cover basic chat scenarios:

Role	Level	Description
user	User	Default User role
guest	User	Used for guest users created by server-side endpoints. Guests are short-lived temporary users that could be created without a token
anonymous	User	Anonymous users are not allowed to perform any actions that write data. You should treat them as unathenticated clients
admin	User	Role for users that perform administrative tasks with elevated permissions
channel_member	Channel	Default role that gets assigned when user is added to the channel
channel_moderator	Channel	Role for channel members that perform administrative tasks with elevated permissions
It’s worth noting that you cannot use user-level roles as channel-level roles vice-versa. This restriction only applies to builtin roles

Ownership
Some Stream Chat entities have an owner and the fact of ownership can be considered when configuring access permissions. Ownership is supported in these entity types:

Channel - owned by its creator

Message - owned by its creator (sender)

Attachment - owned by user who uploaded a file

User - authenticated user owns itself

Using ownership concept, permissions could be set up in such a way that allows entity owners to perform certain actions. For example:

Update Own Message - allows message senders to edit their messages

Update Own User - allows users to change their own properties (except role and team)

Send Message in Own Channel - allows channel creators to send messages in the channels that they created even if they are not members

Custom Roles
In more sophisticated scenarios custom roles could be used. One Stream Chat application could have up to 25 custom roles. Roles are simple, and require only a name to be created. They do nothing until permissions are assigned to the role. To create new custom role you can use CreateRole API endpoint:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

await client.createRole("special_agent");
To delete previously created role you can use DeleteRole API endpoint:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

await client.deleteRole("agent_006");
In order to delete a role, you have to remove all permission grants that this role has and make sure that you don’t have non-deleted users with this role assigned. Channel-level roles could be deleted without reassigning them, although, some users could lose access to channels where this role is used.

Once you have a role created you can start granting permissions to it. You can also grant or remove permissions for built in roles.

Granting permissions
User access in Chat application is split across multiple scopes.

Application Permissions : You can grant these using the .app scope. These permissions apply to operations that occur outside of channel-types including accessing and modifying other users, or using moderation features.

Channel-Type Permissions : These apply permissions to all channels of a particular type.

Channel Permissions : These apply permissions to a single channel and override channel-type permissions.

To list all available permissions you can you ListPermissions API endpoint:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

const { permissions } = await client.listPermissions(); // List of Permission objects
You can also find all available permissions on Permissions Reference page

Each permission object contains these fields:

Type	Description	Description	Example
id	string	Unique permission ID	create-message-owner
name	string	Human-readable permission name	Create Message in Owned Channel
description	string	Human-readable permission description	Grants action CreateMessage which allows to send a new message, user should own a channel
action	string	Action which this permission grants	CreateMessage
owner	boolean	If true, Subject should be an owner of the Resource	true
same_team	boolean	If true, Subject should be a part of the team that Resource is a part of	true
To manipulate granted permissions for certain channel type, you can use UpdateChannelType API endpoint:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

// observe current grants of the channel type
const { grants } = await client.getChannelType("messaging");
// update "channel_member" role grants in "messaging" scope
await client.updateChannelType("messaging", {
  grants: {
    channel_member: [
      "read-channel", // allow access to the channel
      "create-message", // create messages in the channel
      "update-message-owner", // update own user messages
      "delete-message-owner", // delete own user messages
    ],
  },
});
This call will only change grants of roles that were mentioned in the request. You can remove all role grants with providing empty array ( [] ) as list of granted permissions:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

await client.updateChannelType("messaging", {
  grants: {
    guest: [], // removes all grants of "guest" role
    anonymous: [], // removes all grants of "anonymous" role
  },
});
If you want to reset the whole scope to default settings, you can explicitly provide null to grants field:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

await client.updateChannelType("messaging", {
  grants: null, // resets the whole scope to default settings
});
You can manipulate .app scope grants using UpdateApp API endpoint in exactly the same way:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

// update grants of multiple roles in ".app" scope
await client.updateApp({
  grants: {
    anonymous: [],
    guest: [],
    user: ["search-user", "mute-user"],
    admin: ["search-user", "mute-user", "ban-user"],
  },
});
UI for configuring permissions
Stream Dashboard provides a user interface to edit permission grants. This UI is available on Chat > Roles & Permissions page which is available after switching to version 2 of permissions.


Channel-level permissions
In some cases it makes sense to slightly modify granted permissions for the channel without changing channel-type grants configuration. For this, you can use Grants Modifiers that you can set for each channel individually. Grants Modifiers look almost exactly the same as regular Grants object except it allows to revoke permissions as well as grant new ones. For example, if we want to disallow sending links for users with role “user” in channel “livestream:example” and allow creating reactions, we can do this:


JavaScript

PHP

Python

Java

C#

Ruby

Go

Unity

await channel.updatePartial({
  set: {
    config_overrides: {
      grants: {
        user: ["!add-links", "create-reaction"],
      },
    },
  },
});
Exclamation mark ( ! ) here means “revoke” and you can combine any number of “revoke” and “grant” modifiers

After modifying the granted channel-level permissions, the API will enrich the channel response with the grants field under data.config.grants

The field config_overrides can only be updated using server-side auth

Broadcast and Reply-only Channels
A common example of changing the permission model of a channel type is to create a Telegram-style broadcast channel where privileged channel members can send messages and other members may have permissions restricted to reading, reactions, or replying.

The three Permission grants to modify these under the scope of the channel type are

Read Channel
Create Reaction
Create Reply
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Permissions v1 (legacy)
Next
Reference
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Reference
Reference
This reference contains some useful information about permission system, applicable to both versions.

Actions
In the table below you will find all available actions of Stream Chat permission system

Action	Resource Type	Description
AddLinks	Channel	Allows user to add URLs into messages
AddOwnChannelMembership	Channel	Allows user to add own channel membership (join channel)
BanChannelMember	Channel	Allows user to ban channel members
CreateChannel	Channel	Allows user to create a new channel
CreateDistinctChannelForOthers	Channel	Allows user to create new distinct channel for other users (e.g. user A creates channel for users B and C)
CreateMessage	Channel	Allows user to send a new message
CreateAttachment	Channel	Allows user to send a new message with attachments
CreateMention	Channel	Allows user to send a new message with mentions
CreateReaction	Channel	Allows user to add a reaction to a message
CreateSystemMessage	Channel	Allows user to send a new system message
DeleteChannel	Channel	Allows user to delete a channel
DeleteReaction	Channel	Allows user to delete a reaction
FlagMessage	Channel	Allows user to flag messages
MuteChannel	Channel	Allows user to mute and unmute channel
PinMessage	Channel	Allows user to pin a message
ReadChannel	Channel	Allows user to read messages from the channel
ReadChannelMembers	Channel	Allows user to read channel members
ReadDisabledChannel	User	Allows user to read disabled channels (regardless of channel membership)
ReadMessageFlags	Channel	Allows user to access messages that have been flagged
RecreateChannel	Channel	Allows user to recreate a channel when it got deleted
RemoveOwnChannelMembership	Channel	Allows user to leave the channel (remove own channel membership)
SendCustomEvent	Channel	Allows user to send custom events to a channel
SkipChannelCooldown	Channel	Allows user to bypass existing cooldown in a channel
SkipMessageModeration	Channel	Allows user to bypass automatic message moderation
TruncateChannel	Channel	Allows user to truncate a channel
UpdateChannel	Channel	Allows user to update channel data
UpdateChannelCooldown	Channel	Allows user to set and unset cooldown time for a channel (slow mode)
UpdateChannelFrozen	Channel	Allows user to freeze and unfreeze a channel
UpdateChannelMembers	Channel	Allows user to add, modify and remove channel members
UploadAttachment	Channel	Allows user to upload files and images
UseFrozenChannel	Channel	Allows user to send messages and reactions to a frozen channels
DeleteMessage	Message	Allows user to delete a message
RunMessageAction	Message	Allows user to run an action against a message
UnblockMessage	Message	Allows user to unblock message blocked by automatic moderation
UpdateMessage	Message	Allows user to update a message
DeleteAttachment	Attachment	Allows user to delete uploaded files and images
BanUser	User	Allows user to ban users
FlagUser	User	Allows user to flag users
MuteUser	User	Allows user to mute and unmute users
SearchUser	User	Allows user to search for other users
UpdateUser	User	Allows user to update users
UpdateUserRole	User	Allows user to update user roles
UpdateUserTeams	User	Allows user to update user teams
CreateRestrictedVisibilityMessage	User	Allows user to create restricted visibility messages
ReadRestrictedVisibilityMessage	User	Allows user to read restricted visibility messages
BlockUser	Call	Allows user to Block and unblock users on calls
CreateCall	Call	Allows user to creates a call
CreateCallReaction	Call	Allows user to Add a reaction to a call
DeleteRecording	Call	Allows user to Delete recording
EndCall	Call	Allows user to terminates a call
JoinBackstage	Call	Allows user to joins a call backstage
JoinCall	Call	Allows user to joins a call
JoinEndedCall	Call	Allows user to joins a call that was marked as ended
ListRecordings	Call	Allows user to List recordings
MuteUsers	Call	Allows user to MuteUsers
PinCallTrack	Call	Allows user to Pin/Unpin a track for everyone in the call
ReadCall	Call	Allows user to read a call
ReadFlagReports	FlagReport	Allows user to read flag reports
RemoveCallMember	Call	Allows user to Remove a participant
Screenshare	Call	Allows user to Screenshare
SendAudio	Call	Allows user to Send audio
SendEvent	Call	Allows user to SendEvent
SendVideo	Call	Allows user to Send video
StartBroadcasting	Call	Allows user to Start broadcasting
StartRecording	Call	Allows user to Start recording
StartTranscription	Call	Allows user to Start transcription
StopBroadcasting	Call	Allows user to Stop broadcasting
StopRecording	Call	Allows user to Stop recording
StopTranscription	Call	Allows user to Stop transcription
UpdateCall	Call	Allows user to update the data for a call
UpdateCallMember	Call	Allows user to Update a participant
UpdateCallMemberRole	Call	Allows user to Update role for participants
UpdateCallPermissions	Call	Allows user to UpdateCallPermissions
UpdateCallSettings	Call	Allows user to updates settings of a call
UpdateFlagReport	FlagReport	Allows user to update flag report
Default Grants
In tables below you will find default permission grants for each builtin channel type as well as .app permission scope.

For each of of the above actions, there are different built in permissions depending on whether the object was created by the user or not. For example, users can be given permissions to delete-attachment which allows for deleting any message attachments, or they can be given permissions to delete-attachment-owned to restrict this to only attachments added by the current user.

Every custom channel type that you create using CreateChannelType API endpoint, will have messaging scope grants by default.

Scope video:development
Permission ID	admin	user	guest	anonymous
block-user	✅	✅	✖️	✖️
create-call	✅	✅	✖️	✖️
create-call-reaction	✅	✅	✖️	✖️
end-call	✅	✅	✖️	✖️
join-backstage	✅	✅	✖️	✖️
join-call	✅	✅	✅	✅
join-ended-call	✅	✅	✖️	✖️
list-recordings	✅	✅	✖️	✖️
mute-users	✅	✅	✖️	✖️
pin-call-track	✅	✅	✖️	✖️
read-call	✅	✅	✅	✅
remove-call-member	✅	✅	✖️	✖️
screenshare	✅	✅	✖️	✖️
send-audio	✅	✅	✅	✖️
send-event	✅	✅	✅	✖️
send-video	✅	✅	✅	✖️
start-broadcasting	✅	✅	✖️	✖️
start-recording	✅	✅	✖️	✖️
start-transcription	✅	✅	✖️	✖️
stop-broadcasting	✅	✅	✖️	✖️
stop-recording	✅	✅	✖️	✖️
stop-transcription	✅	✅	✖️	✖️
update-call	✅	✅	✖️	✖️
update-call-member	✅	✅	✖️	✖️
update-call-member-role	✅	✅	✖️	✖️
update-call-permissions	✅	✅	✖️	✖️
update-call-settings	✅	✅	✖️	✖️
Scope video:livestream
Permission ID	admin	user	anonymous
block-user	✅	✖️	✖️
block-user-owner	✖️	✅	✖️
create-call	✅	✅	✖️
create-call-reaction	✅	✅	✖️
end-call	✅	✖️	✖️
end-call-owner	✖️	✅	✖️
join-backstage	✅	✖️	✖️
join-backstage-owner	✖️	✅	✖️
join-call	✅	✅	✅
join-ended-call	✅	✖️	✖️
join-ended-call-owner	✖️	✅	✖️
mute-users	✅	✖️	✖️
mute-users-owner	✖️	✅	✖️
pin-call-track	✅	✖️	✖️
pin-call-track-owner	✖️	✅	✖️
read-call	✅	✅	✅
remove-call-member	✅	✖️	✖️
remove-call-member-owner	✖️	✅	✖️
screenshare	✅	✖️	✖️
screenshare-owner	✖️	✅	✖️
send-audio	✅	✖️	✖️
send-audio-owner	✖️	✅	✖️
send-event	✅	✅	✖️
send-video	✅	✖️	✖️
send-video-owner	✖️	✅	✖️
start-broadcasting	✅	✖️	✖️
start-broadcasting-owner	✖️	✅	✖️
start-recording	✅	✖️	✖️
start-recording-owner	✖️	✅	✖️
stop-broadcasting	✅	✖️	✖️
stop-broadcasting-owner	✖️	✅	✖️
stop-recording	✅	✖️	✖️
stop-recording-owner	✖️	✅	✖️
update-call	✅	✖️	✖️
update-call-member	✅	✖️	✖️
update-call-member-owner	✖️	✅	✖️
update-call-member-role	✅	✖️	✖️
update-call-member-role-owner	✖️	✅	✖️
update-call-owner	✖️	✅	✖️
update-call-permissions	✅	✖️	✖️
update-call-permissions-owner	✖️	✅	✖️
update-call-settings	✅	✖️	✖️
Scope video:audio_room
Permission ID	admin	user	anonymous
block-user	✅	✖️	✖️
block-user-owner	✖️	✅	✖️
create-call	✅	✅	✖️
create-call-reaction	✅	✅	✖️
end-call	✅	✖️	✖️
end-call-owner	✖️	✅	✖️
join-backstage	✅	✖️	✖️
join-backstage-owner	✖️	✅	✖️
join-call	✅	✅	✅
join-ended-call	✅	✖️	✖️
join-ended-call-owner	✖️	✅	✖️
mute-users	✅	✖️	✖️
mute-users-owner	✖️	✅	✖️
read-call	✅	✅	✅
remove-call-member	✅	✖️	✖️
remove-call-member-owner	✖️	✅	✖️
screenshare	✅	✖️	✖️
send-audio	✅	✖️	✖️
send-audio-owner	✖️	✅	✖️
send-event	✅	✅	✖️
start-broadcasting	✅	✖️	✖️
start-broadcasting-owner	✖️	✅	✖️
start-recording	✅	✖️	✖️
start-recording-owner	✖️	✅	✖️
start-transcription	✅	✖️	✖️
start-transcription-owner	✖️	✅	✖️
stop-broadcasting	✅	✖️	✖️
stop-broadcasting-owner	✖️	✅	✖️
stop-recording	✅	✖️	✖️
stop-recording-owner	✖️	✅	✖️
stop-transcription	✅	✖️	✖️
stop-transcription-owner	✖️	✅	✖️
update-call	✅	✖️	✖️
update-call-member	✅	✖️	✖️
update-call-member-owner	✖️	✅	✖️
update-call-member-role	✅	✖️	✖️
update-call-member-role-owner	✖️	✅	✖️
update-call-owner	✖️	✅	✖️
update-call-permissions	✅	✖️	✖️
update-call-permissions-owner	✖️	✅	✖️
update-call-settings	✅	✖️	✖️
update-call-settings-owner	✖️	✅	✖️
Scope .app
Permission ID	admin	moderator	user	guest
flag-user	✅	✅	✅	✅
mute-user	✅	✅	✅	✅
read-flag-reports	✅	✅	✖️	✖️
search-user	✅	✅	✅	✅
update-flag-report	✅	✅	✖️	✖️
update-user-owner	✅	✅	✅	✅
Scope video:default
Permission ID	admin	user	guest
block-user	✅	✖️	✖️
block-user-owner	✖️	✅	✖️
create-call	✅	✅	✖️
create-call-reaction	✅	✅	✖️
delete-recording	✅	✖️	✖️
end-call	✅	✅	✖️
join-backstage	✅	✖️	✖️
join-call	✅	✅	✅
join-ended-call	✅	✅	✖️
list-recordings	✅	✅	✖️
mute-users	✅	✖️	✖️
mute-users-owner	✖️	✅	✖️
pin-call-track	✅	✖️	✖️
pin-call-track-owner	✖️	✅	✖️
read-call	✅	✅	✅
remove-call-member	✅	✅	✖️
screenshare	✅	✅	✖️
send-audio	✅	✅	✅
send-event	✅	✅	✅
send-video	✅	✅	✅
start-broadcasting	✅	✅	✖️
start-recording	✅	✅	✖️
start-transcription	✅	✅	✖️
stop-broadcasting	✅	✅	✖️
stop-recording	✅	✅	✖️
stop-transcription	✅	✅	✖️
update-call	✅	✖️	✖️
update-call-member	✅	✅	✖️
update-call-member-role	✅	✖️	✖️
update-call-owner	✖️	✅	✖️
update-call-permissions	✅	✖️	✖️
update-call-permissions-owner	✖️	✅	✖️
update-call-settings	✅	✖️	✖️
update-call-settings-owner	✖️	✅	✖️
Scope messaging
Permission ID	admin	moderator	user	channel_member	channel_moderator
add-links	✅	✅	✖️	✅	✅
add-links-owner	✖️	✖️	✅	✖️	✖️
ban-channel-member	✅	✅	✖️	✖️	✅
ban-user	✅	✅	✖️	✖️	✖️
create-call	✅	✅	✖️	✅	✅
create-channel	✅	✅	✅	✖️	✖️
create-message	✅	✅	✖️	✅	✅
create-message-owner	✖️	✖️	✅	✖️	✖️
create-attachment	✅	✅	✖️	✅	✅
create-attachment-owner	✖️	✖️	✅	✖️	✖️
create-mention	✅	✅	✖️	✅	✅
create-mention-owner	✖️	✖️	✅	✖️	✖️
create-reaction	✅	✅	✖️	✅	✅
create-reaction-owner	✖️	✖️	✅	✖️	✖️
create-system-message	✅	✅	✖️	✖️	✅
delete-attachment	✅	✅	✖️	✖️	✅
delete-attachment-owner	✖️	✖️	✅	✖️	✖️
delete-channel	✅	✖️	✖️	✖️	✖️
delete-channel-owner	✖️	✅	✅	✖️	✖️
delete-message	✅	✅	✖️	✖️	✅
delete-message-owner	✖️	✖️	✅	✖️	✖️
delete-reaction	✅	✅	✖️	✖️	✅
delete-reaction-owner	✖️	✖️	✅	✖️	✖️
flag-message	✅	✅	✖️	✅	✅
flag-message-owner	✖️	✖️	✅	✖️	✖️
join-call	✅	✅	✖️	✅	✅
mute-channel	✅	✅	✖️	✅	✅
mute-channel-owner	✖️	✖️	✅	✖️	✖️
pin-message	✅	✅	✖️	✅	✅
pin-message-owner	✖️	✖️	✅	✖️	✖️
read-channel	✅	✅	✖️	✅	✅
read-channel-members	✅	✅	✖️	✅	✅
read-channel-members-owner	✖️	✖️	✅	✖️	✖️
read-channel-owner	✖️	✖️	✅	✖️	✖️
read-message-flags	✅	✅	✖️	✖️	✅
recreate-channel	✅	✖️	✖️	✖️	✖️
recreate-channel-owner	✖️	✅	✅	✖️	✖️
remove-own-channel-membership	✅	✅	✖️	✅	✅
remove-own-channel-membership-owner	✖️	✖️	✅	✖️	✖️
run-message-action	✅	✅	✖️	✅	✅
run-message-action-owner	✖️	✖️	✅	✖️	✖️
send-custom-event	✅	✅	✖️	✅	✅
send-custom-event-owner	✖️	✖️	✅	✖️	✖️
skip-channel-cooldown	✅	✅	✖️	✖️	✅
skip-message-moderation	✅	✅	✖️	✖️	✅
truncate-channel	✅	✖️	✖️	✖️	✖️
truncate-channel-owner	✖️	✅	✅	✖️	✖️
unblock-message	✅	✅	✖️	✖️	✅
update-channel	✅	✅	✖️	✖️	✅
update-channel-cooldown	✅	✅	✖️	✖️	✅
update-channel-frozen	✅	✅	✖️	✖️	✅
update-channel-members	✅	✅	✖️	✖️	✅
update-channel-members-owner	✖️	✖️	✅	✖️	✖️
update-channel-owner	✖️	✖️	✅	✖️	✖️
update-message	✅	✅	✖️	✖️	✅
update-message-owner	✖️	✖️	✅	✖️	✖️
upload-attachment	✅	✅	✖️	✅	✅
upload-attachment-owner	✖️	✖️	✅	✖️	✖️
Scope livestream
Permission ID	admin	moderator	user	channel_moderator	guest	anonymous
add-links	✅	✅	✅	✖️	✖️	✖️
ban-channel-member	✅	✅	✖️	✅	✖️	✖️
ban-user	✅	✅	✖️	✖️	✖️	✖️
create-call	✅	✅	✖️	✅	✖️	✖️
create-channel	✅	✅	✅	✖️	✖️	✖️
create-message	✅	✅	✅	✖️	✖️	✖️
create-attachment	✅	✅	✅	✖️	✖️	✖️
create-mention	✅	✅	✅	✖️	✖️	✖️
create-reaction	✅	✅	✅	✖️	✖️	✖️
create-system-message	✅	✅	✖️	✅	✖️	✖️
delete-attachment	✅	✅	✖️	✅	✖️	✖️
delete-attachment-owner	✖️	✖️	✅	✖️	✖️	✖️
delete-channel	✅	✖️	✖️	✖️	✖️	✖️
delete-message	✅	✅	✖️	✅	✖️	✖️
delete-message-owner	✖️	✖️	✅	✖️	✖️	✖️
delete-reaction	✅	✅	✖️	✅	✖️	✖️
delete-reaction-owner	✖️	✖️	✅	✖️	✖️	✖️
flag-message	✅	✅	✅	✖️	✅	✖️
join-call	✅	✅	✅	✖️	✅	✅
mute-channel	✅	✅	✅	✖️	✅	✖️
pin-message	✅	✅	✖️	✅	✖️	✖️
pin-message-owner	✖️	✖️	✅	✖️	✖️	✖️
read-channel	✅	✅	✅	✖️	✅	✅
read-channel-members	✅	✅	✅	✖️	✅	✅
read-message-flags	✅	✅	✖️	✅	✖️	✖️
recreate-channel	✅	✖️	✖️	✖️	✖️	✖️
remove-own-channel-membership	✅	✖️	✖️	✖️	✖️	✖️
run-message-action	✅	✅	✅	✖️	✖️	✖️
send-custom-event	✅	✅	✅	✖️	✖️	✖️
skip-channel-cooldown	✅	✅	✖️	✅	✖️	✖️
skip-message-moderation	✅	✅	✖️	✅	✖️	✖️
truncate-channel	✅	✖️	✖️	✖️	✖️	✖️
unblock-message	✅	✅	✖️	✅	✖️	✖️
update-channel	✅	✖️	✖️	✖️	✖️	✖️
update-channel-cooldown	✅	✅	✖️	✅	✖️	✖️
update-channel-frozen	✅	✅	✖️	✅	✖️	✖️
update-channel-members	✅	✖️	✖️	✖️	✖️	✖️
update-message	✅	✅	✖️	✅	✖️	✖️
update-message-owner	✖️	✖️	✅	✖️	✖️	✖️
upload-attachment	✅	✅	✅	✖️	✖️	✖️
Scope team
Permission ID	admin	moderator	user	channel_member	channel_moderator
add-links	✅	✅	✖️	✅	✅
add-links-owner	✖️	✖️	✅	✖️	✖️
ban-channel-member	✅	✅	✖️	✖️	✅
ban-user	✅	✅	✖️	✖️	✖️
create-call	✅	✅	✖️	✅	✅
create-channel	✅	✅	✅	✖️	✖️
create-message	✅	✅	✖️	✅	✅
create-message-owner	✖️	✖️	✅	✖️	✖️
create-attachment	✅	✅	✖️	✅	✅
create-attachment-owner	✖️	✖️	✅	✖️	✖️
create-mention	✅	✅	✖️	✅	✅
create-mention-owner	✖️	✖️	✅	✖️	✖️
create-reaction	✅	✅	✖️	✅	✅
create-reaction-owner	✖️	✖️	✅	✖️	✖️
create-system-message	✅	✅	✖️	✖️	✅
delete-attachment	✅	✅	✖️	✖️	✅
delete-attachment-owner	✖️	✖️	✅	✖️	✖️
delete-channel	✅	✖️	✖️	✖️	✖️
delete-channel-owner	✖️	✅	✅	✖️	✖️
delete-message	✅	✅	✖️	✖️	✅
delete-message-owner	✖️	✖️	✅	✖️	✖️
delete-reaction	✅	✅	✖️	✖️	✅
delete-reaction-owner	✖️	✖️	✅	✖️	✖️
flag-message	✅	✅	✖️	✅	✅
flag-message-owner	✖️	✖️	✅	✖️	✖️
join-call	✅	✅	✖️	✅	✅
mute-channel	✅	✅	✖️	✅	✅
mute-channel-owner	✖️	✖️	✅	✖️	✖️
pin-message	✅	✅	✖️	✅	✅
pin-message-owner	✖️	✖️	✅	✖️	✖️
read-channel	✅	✅	✖️	✅	✅
read-channel-members	✅	✅	✖️	✅	✅
read-channel-members-owner	✖️	✖️	✅	✖️	✖️
read-channel-owner	✖️	✖️	✅	✖️	✖️
read-message-flags	✅	✅	✖️	✖️	✅
recreate-channel	✅	✖️	✖️	✖️	✖️
recreate-channel-owner	✖️	✅	✅	✖️	✖️
remove-own-channel-membership	✅	✅	✖️	✅	✅
remove-own-channel-membership-owner	✖️	✖️	✅	✖️	✖️
run-message-action	✅	✅	✖️	✅	✅
run-message-action-owner	✖️	✖️	✅	✖️	✖️
send-custom-event	✅	✅	✖️	✅	✅
send-custom-event-owner	✖️	✖️	✅	✖️	✖️
skip-channel-cooldown	✅	✅	✖️	✖️	✅
skip-message-moderation	✅	✅	✖️	✖️	✅
truncate-channel	✅	✖️	✖️	✖️	✖️
truncate-channel-owner	✖️	✅	✅	✖️	✖️
unblock-message	✅	✅	✖️	✖️	✅
update-channel	✅	✅	✖️	✖️	✅
update-channel-cooldown	✅	✅	✖️	✖️	✅
update-channel-frozen	✅	✅	✖️	✖️	✅
update-channel-members	✅	✅	✖️	✖️	✅
update-channel-members-owner	✖️	✖️	✅	✖️	✖️
update-channel-owner	✖️	✖️	✅	✖️	✖️
update-message	✅	✅	✖️	✖️	✅
update-message-owner	✖️	✖️	✅	✖️	✖️
upload-attachment	✅	✅	✖️	✅	✅
upload-attachment-owner	✖️	✖️	✅	✖️	✖️
Scope commerce
Permission ID	admin	moderator	user	channel_member	channel_moderator	guest
add-links	✅	✅	✖️	✅	✅	✅
add-links-owner	✖️	✖️	✅	✖️	✖️	✖️
ban-channel-member	✅	✅	✖️	✖️	✅	✖️
ban-user	✅	✅	✖️	✖️	✖️	✖️
create-call	✅	✅	✖️	✖️	✅	✖️
create-channel	✅	✅	✖️	✖️	✖️	✅
create-message	✅	✅	✖️	✅	✅	✖️
create-message-owner	✖️	✖️	✅	✖️	✖️	✖️
create-attachment	✅	✅	✖️	✅	✅	✖️
create-attachment-owner	✖️	✖️	✅	✖️	✖️	✖️
create-mention	✅	✅	✖️	✅	✅	✖️
create-mention-owner	✖️	✖️	✅	✖️	✖️	✖️
create-reaction	✅	✅	✖️	✅	✅	✖️
create-reaction-owner	✖️	✖️	✅	✖️	✖️	✖️
create-system-message	✅	✅	✖️	✖️	✅	✖️
delete-attachment	✅	✅	✖️	✖️	✅	✖️
delete-attachment-owner	✖️	✖️	✅	✖️	✖️	✅
delete-channel	✅	✖️	✖️	✖️	✖️	✖️
delete-message	✅	✅	✖️	✖️	✅	✖️
delete-message-owner	✖️	✖️	✅	✖️	✖️	✅
delete-reaction	✅	✅	✖️	✖️	✅	✖️
delete-reaction-owner	✖️	✖️	✅	✖️	✖️	✅
flag-message	✅	✅	✖️	✅	✅	✖️
flag-message-owner	✖️	✖️	✅	✖️	✖️	✅
join-call	✅	✅	✖️	✅	✅	✖️
mute-channel	✅	✅	✖️	✅	✅	✖️
mute-channel-owner	✖️	✖️	✅	✖️	✖️	✅
pin-message	✅	✅	✖️	✖️	✅	✖️
pin-message-owner	✖️	✖️	✅	✖️	✖️	✅
read-channel	✅	✅	✖️	✅	✅	✖️
read-channel-members	✅	✅	✖️	✅	✅	✖️
read-channel-members-owner	✖️	✖️	✅	✖️	✖️	✅
read-channel-owner	✖️	✖️	✅	✖️	✖️	✅
read-message-flags	✅	✅	✖️	✖️	✅	✖️
recreate-channel	✅	✖️	✖️	✖️	✖️	✖️
remove-own-channel-membership	✅	✅	✖️	✅	✅	✖️
remove-own-channel-membership-owner	✖️	✖️	✅	✖️	✖️	✖️
run-message-action	✅	✅	✖️	✅	✅	✖️
run-message-action-owner	✖️	✖️	✅	✖️	✖️	✖️
send-custom-event	✅	✅	✖️	✅	✅	✖️
send-custom-event-owner	✖️	✖️	✅	✖️	✖️	✖️
skip-channel-cooldown	✅	✅	✖️	✖️	✅	✖️
skip-message-moderation	✅	✅	✖️	✖️	✅	✖️
truncate-channel	✅	✖️	✖️	✖️	✖️	✖️
unblock-message	✅	✅	✖️	✖️	✅	✖️
update-channel	✅	✅	✖️	✖️	✅	✖️
update-channel-cooldown	✅	✅	✖️	✖️	✅	✖️
update-channel-frozen	✅	✅	✖️	✖️	✅	✖️
update-channel-members	✅	✅	✖️	✖️	✅	✖️
update-channel-members-owner	✖️	✖️	✅	✖️	✖️	✅
update-message	✅	✅	✖️	✖️	✅	✖️
update-message-owner	✖️	✖️	✅	✖️	✖️	✅
upload-attachment	✅	✅	✖️	✅	✅	✅
upload-attachment-owner	✖️	✖️	✅	✖️	✖️	✖️
Scope gaming
Permission ID	admin	moderator	user	channel_member	channel_moderator
add-links	✅	✅	✖️	✅	✅
add-links-owner	✖️	✖️	✅	✖️	✖️
ban-channel-member	✅	✅	✖️	✖️	✅
ban-user	✅	✅	✖️	✖️	✖️
create-call	✅	✅	✖️	✅	✅
create-channel	✅	✖️	✖️	✖️	✖️
create-message	✅	✅	✖️	✅	✅
create-message-owner	✖️	✖️	✅	✖️	✖️
create-attachment	✅	✅	✖️	✅	✅
create-attachment-owner	✖️	✖️	✅	✖️	✖️
create-mention	✅	✅	✖️	✅	✅
create-mention-owner	✖️	✖️	✅	✖️	✖️
create-reaction	✅	✅	✖️	✅	✅
create-reaction-owner	✖️	✖️	✅	✖️	✖️
create-system-message	✅	✅	✖️	✖️	✅
delete-attachment	✅	✅	✖️	✖️	✅
delete-attachment-owner	✖️	✖️	✅	✖️	✖️
delete-channel	✅	✖️	✖️	✖️	✖️
delete-message	✅	✅	✖️	✖️	✅
delete-message-owner	✖️	✖️	✅	✖️	✖️
delete-reaction	✅	✅	✖️	✖️	✅
delete-reaction-owner	✖️	✖️	✅	✖️	✖️
flag-message	✅	✅	✖️	✅	✅
flag-message-owner	✖️	✖️	✅	✖️	✖️
join-call	✅	✅	✖️	✅	✅
mute-channel	✅	✅	✖️	✅	✅
mute-channel-owner	✖️	✖️	✅	✖️	✖️
pin-message	✅	✅	✖️	✖️	✅
read-channel	✅	✅	✖️	✅	✅
read-channel-members	✅	✅	✖️	✅	✅
read-channel-members-owner	✖️	✖️	✅	✖️	✖️
read-channel-owner	✖️	✖️	✅	✖️	✖️
read-message-flags	✅	✅	✖️	✖️	✅
recreate-channel	✅	✖️	✖️	✖️	✖️
remove-own-channel-membership	✅	✅	✖️	✅	✅
remove-own-channel-membership-owner	✖️	✖️	✅	✖️	✖️
run-message-action	✅	✅	✖️	✅	✅
run-message-action-owner	✖️	✖️	✅	✖️	✖️
send-custom-event	✅	✅	✖️	✅	✅
send-custom-event-owner	✖️	✖️	✅	✖️	✖️
skip-channel-cooldown	✅	✅	✖️	✖️	✅
skip-message-moderation	✅	✅	✖️	✖️	✅
truncate-channel	✅	✖️	✖️	✖️	✖️
unblock-message	✅	✅	✖️	✖️	✅
update-channel	✅	✖️	✖️	✖️	✖️
update-channel-cooldown	✅	✅	✖️	✖️	✅
update-channel-frozen	✅	✅	✖️	✖️	✅
update-channel-members	✅	✖️	✖️	✖️	✖️
update-message	✅	✅	✖️	✖️	✅
update-message-owner	✖️	✖️	✅	✖️	✖️
upload-attachment	✅	✅	✖️	✅	✅
upload-attachment-owner	✖️	✖️	✅	✖️	✖️
Multi-Tenant Default Grants
In tables below you will find default permission grants for builtin roles that designed for multi-tenant applications. They are useful for multi-tenant applications only.

By default, for multi-tenant applications, all objects (users, channels, and messages) must belong to the same team to be able to interact. These multi-tenant permissions enable overriding that behavior, so that certain users can have permissions to interact with objects on any team

Scope video:livestream
Permission ID
Scope video:development
Permission ID
Scope .app
Permission ID	global_moderator	global_admin
flag-user-any-team	✅	✅
mute-user-any-team	✅	✅
read-flag-reports-any-team	✅	✅
search-user-any-team	✅	✅
update-flag-report-any-team	✅	✅
update-user-owner	✅	✅
Scope video:audio_room
Permission ID
Scope video:default
Permission ID
Scope messaging
Permission ID	global_moderator	global_admin
add-links-any-team	✅	✅
ban-channel-member-any-team	✅	✅
ban-user-any-team	✅	✅
create-call-any-team	✅	✅
create-channel-any-team	✅	✅
create-message-any-team	✅	✅
create-attachment-any-team	✅	✅
create-mention-any-team	✅	✅
create-reaction-any-team	✅	✅
create-system-message-any-team	✅	✅
delete-attachment-any-team	✅	✅
delete-channel-any-team	✖️	✅
delete-channel-owner-any-team	✅	✖️
delete-message-any-team	✅	✅
delete-reaction-any-team	✅	✅
flag-message-any-team	✅	✅
join-call-any-team	✅	✅
mute-channel-any-team	✅	✅
pin-message-any-team	✅	✅
read-channel-any-team	✅	✅
read-channel-members-any-team	✅	✅
read-message-flags-any-team	✅	✅
recreate-channel-any-team	✖️	✅
recreate-channel-owner-any-team	✅	✖️
remove-own-channel-membership-any-team	✅	✅
run-message-action-any-team	✅	✅
send-custom-event-any-team	✅	✅
skip-channel-cooldown-any-team	✅	✅
skip-message-moderation-any-team	✅	✅
truncate-channel-any-team	✖️	✅
truncate-channel-owner-any-team	✅	✖️
unblock-message-any-team	✅	✅
update-channel-any-team	✅	✅
update-channel-cooldown-any-team	✅	✅
update-channel-frozen-any-team	✅	✅
update-channel-members-any-team	✅	✅
update-message-any-team	✅	✅
upload-attachment-any-team	✅	✅
Scope livestream
Permission ID	global_moderator	global_admin
add-links-any-team	✅	✅
ban-channel-member-any-team	✅	✅
ban-user-any-team	✅	✅
create-call-any-team	✅	✅
create-channel-any-team	✅	✅
create-message-any-team	✅	✅
create-attachment-any-team	✅	✅
create-mention-any-team	✅	✅
create-reaction-any-team	✅	✅
create-system-message-any-team	✅	✅
delete-attachment-any-team	✅	✅
delete-channel-any-team	✖️	✅
delete-message-any-team	✅	✅
delete-reaction-any-team	✅	✅
flag-message-any-team	✅	✅
join-call-any-team	✅	✅
mute-channel-any-team	✅	✅
pin-message-any-team	✅	✅
read-channel-any-team	✅	✅
read-channel-members-any-team	✅	✅
read-message-flags-any-team	✅	✅
recreate-channel-any-team	✖️	✅
remove-own-channel-membership-any-team	✖️	✅
run-message-action-any-team	✅	✅
send-custom-event-any-team	✅	✅
skip-channel-cooldown-any-team	✅	✅
skip-message-moderation-any-team	✅	✅
truncate-channel-any-team	✖️	✅
unblock-message-any-team	✅	✅
update-channel-any-team	✖️	✅
update-channel-cooldown-any-team	✅	✅
update-channel-frozen-any-team	✅	✅
update-channel-members-any-team	✖️	✅
update-message-any-team	✅	✅
upload-attachment-any-team	✅	✅
Scope team
Permission ID	global_moderator	global_admin
add-links-any-team	✅	✅
ban-channel-member-any-team	✅	✅
ban-user-any-team	✅	✅
create-call-any-team	✅	✅
create-channel-any-team	✅	✅
create-message-any-team	✅	✅
create-attachment-any-team	✅	✅
create-mention-any-team	✅	✅
create-reaction-any-team	✅	✅
create-system-message-any-team	✅	✅
delete-attachment-any-team	✅	✅
delete-channel-any-team	✖️	✅
delete-channel-owner-any-team	✅	✖️
delete-message-any-team	✅	✅
delete-reaction-any-team	✅	✅
flag-message-any-team	✅	✅
join-call-any-team	✅	✅
mute-channel-any-team	✅	✅
pin-message-any-team	✅	✅
read-channel-any-team	✅	✅
read-channel-members-any-team	✅	✅
read-message-flags-any-team	✅	✅
recreate-channel-any-team	✖️	✅
recreate-channel-owner-any-team	✅	✖️
remove-own-channel-membership-any-team	✅	✅
run-message-action-any-team	✅	✅
send-custom-event-any-team	✅	✅
skip-channel-cooldown-any-team	✅	✅
skip-message-moderation-any-team	✅	✅
truncate-channel-any-team	✖️	✅
truncate-channel-owner-any-team	✅	✖️
unblock-message-any-team	✅	✅
update-channel-any-team	✅	✅
update-channel-cooldown-any-team	✅	✅
update-channel-frozen-any-team	✅	✅
update-channel-members-any-team	✅	✅
update-message-any-team	✅	✅
upload-attachment-any-team	✅	✅
Scope commerce
Permission ID	global_moderator	global_admin
add-links-any-team	✅	✅
ban-channel-member-any-team	✅	✅
ban-user-any-team	✅	✅
create-call-any-team	✅	✅
create-channel-any-team	✅	✅
create-message-any-team	✅	✅
create-attachment-any-team	✅	✅
create-mention-any-team	✅	✅
create-reaction-any-team	✅	✅
create-system-message-any-team	✅	✅
delete-attachment-any-team	✅	✅
delete-channel-any-team	✖️	✅
delete-message-any-team	✅	✅
delete-reaction-any-team	✅	✅
flag-message-any-team	✅	✅
join-call-any-team	✅	✅
mute-channel-any-team	✅	✅
pin-message-any-team	✅	✅
read-channel-any-team	✅	✅
read-channel-members-any-team	✅	✅
read-message-flags-any-team	✅	✅
recreate-channel-any-team	✖️	✅
remove-own-channel-membership-any-team	✅	✅
run-message-action-any-team	✅	✅
send-custom-event-any-team	✅	✅
skip-channel-cooldown-any-team	✅	✅
skip-message-moderation-any-team	✅	✅
truncate-channel-any-team	✖️	✅
unblock-message-any-team	✅	✅
update-channel-any-team	✅	✅
update-channel-cooldown-any-team	✅	✅
update-channel-frozen-any-team	✅	✅
update-channel-members-any-team	✅	✅
update-message-any-team	✅	✅
upload-attachment-any-team	✅	✅
Scope gaming
Permission ID	global_moderator	global_admin
add-links-any-team	✅	✅
ban-channel-member-any-team	✅	✅
ban-user-any-team	✅	✅
create-call-any-team	✅	✅
create-channel-any-team	✖️	✅
create-message-any-team	✅	✅
create-attachment-any-team	✅	✅
create-mention-any-team	✅	✅
create-reaction-any-team	✅	✅
create-system-message-any-team	✅	✅
delete-attachment-any-team	✅	✅
delete-channel-any-team	✖️	✅
delete-message-any-team	✅	✅
delete-reaction-any-team	✅	✅
flag-message-any-team	✅	✅
join-call-any-team	✅	✅
mute-channel-any-team	✅	✅
pin-message-any-team	✅	✅
read-channel-any-team	✅	✅
read-channel-members-any-team	✅	✅
read-message-flags-any-team	✅	✅
recreate-channel-any-team	✖️	✅
remove-own-channel-membership-any-team	✅	✅
run-message-action-any-team	✅	✅
send-custom-event-any-team	✅	✅
skip-channel-cooldown-any-team	✅	✅
skip-message-moderation-any-team	✅	✅
truncate-channel-any-team	✖️	✅
unblock-message-any-team	✅	✅
update-channel-any-team	✖️	✅
update-channel-cooldown-any-team	✅	✅
update-channel-frozen-any-team	✅	✅
update-channel-members-any-team	✖️	✅
update-message-any-team	✅	✅
upload-attachment-any-team	✅	✅
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Permissions v2
Next
Migrating from Legacy
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Migrating from Legacy
Migrating from Legacy
Depending on which client-side SDK you use, the custom permissions checking processes may not be implemented yet and could affect user experience. If you use our client SDKs, we recommend waiting to migrate until there is complete front end support, or test this thoroughly in development first. Updates will be posted here as we add more support.

The migration process is pretty straightforward and mostly automated, but you should consider these facts before you pull the trigger:

Make sure backend of your app does not explicitly sets “permission_version” field to “v1” using UpdateApp API endpoint. This will cause your app to rollback to previous version of permission system

There are some permissions properties which should no longer be used on v2 so it is good to understand how you are using them today

“Permissions” field in UpdateChannelType will not affect new permission system. This field is kept for backward compatibility and it allows you to roll back to version 1 in case you changed your mind

Do not use User.role, ChannelMember.channel_role to determine user capabilities. This kind of check is usually fragile and in case of configuration change, UI will not be representative of the new settings

Do not use ChannelMember.role as it is displaying inconsistent values. This field is kept for backwards compatibility only

Option user_search_disallowed_roles only works with permissions v1. To control set of users who can perform user search you should use application-level permission grants ( .app scope)

If you plan to use custom permissions, make sure your client code does not rely on direct role comparisons. Please see Channel Capabilities page for more info

Prerequisites
In order to use version 2 of permissions system, make sure you use compatible version of SDK

SDK	Minimum version
React	v7.0.0
React Native	v4.0.0
Angular	v2.2.0
Android	v4.27.0
iOS	v4.0.0
Flutter	v3.4.0
Unreal	v1.0.0
Unity	v1.0.0
iOS and Unreal SDKs don’t support Channel Capabilities yet

We strongly recommend to regularly update your SDK dependencies since they constantly improve user experience, resolve bugs and add support for new features

How to migrate
We provide two options for performing a migration

Using Dashboard
When you open a Chat application overview for the app that uses older version of permissions, you will see a popup suggesting you to perform an upgrade.


Click “Upgrade” and wait until the page refreshes. Now you should be able to access new “Roles and Permissions” page to set up the permission settings.

You can also navigate directly to the “Roles & Permissions” page under chat settings and click “Upgrade” on the prompt shown there.


This upgrade option translates old permission settings the new system automatically, but we encourage you to visit “Roles and Permissions” page to double check that the configuration is correct.

Using API
In order to migrate to permissions “v2” you have to perform exactly this API call to UpdateApp API endpoint:


JavaScript

PHP

Python

Java

C#

Ruby

Go

await client.updateAppSettings({
  permission_version: "v2",
  migrate_permissions_to_v2: true,
});
permission_version field controls which permission system version is active. You can switch back and forth without providing any extra fields, but in order to convert all your existing configuration, you should provide "migrate_permissions_to_v2": true. When this flag is present, Chat API translates v1 configuration to v2 for you which ensures that your app functions properly without any interruptions. You can always switch back to v1, but configuration translation only works one way. You can also prepare permissions v2 configuration manually and switch to the new version without providing migrate_permissions_to_v2 flag

We recommend you to take a good look at the resulting grants configuration and make sure that all permissions there are correct. Even better if you can test these configurations in development before updating production

How to switch back
In case something goes wrong for you, you can switch back to legacy permission system:


JavaScript

PHP

Python

Java

C#

Ruby

Go

await client.updateAppSettings({
  permission_version: "v1",
});
New Global Roles
For multi-tenant applications only

Once you migrate to v2 permissions there will be two new roles available. These roles allow users to be Admins or Moderators across all teams. Previously, all users had to belong to a team and could only access channels and messages belonging to the same teams. These new roles allow access to all teams data and are important for users of the Stream Dashboard.

To change the role of Admin Users to Global Admin, or to change the role of Moderators to Global Moderator, you can use UpdateUser API endpoint:


JavaScript

PHP

Python

Java

C#

Ruby

Go

await client.partialUpdateUser({
  id: "james_bond",
  set: { role: "global_moderator" },
});
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Reference
Next
Multi-Tenant & Teams
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Overview
Overview
Almost all API requests are specific to a channel (e.g. add a message to channel “livestream:rockets”) and as we saw already, channels are organized in groups called channel types. All applications start with five default channel types, each have different name and are preconfigured to best fit one use-case.

Channel types can be configured with specific permissions and features.

The five default channel types come with good default permission policies. You can find more information on how to manage permissions in the Channel Types section.

There are five built-in channel types:

Livestream: Sensible defaults in case you want to build chat like YouTube or Twitch.
Messaging: Configured for apps such as WhatsApp or Facebook Messenger.
Team: If you want to build your own version of Slack or something similar, start here.
Commerce: Good defaults for building something like your own version of Intercom or Drift.
Gaming: Defaults for adding chat to video games.
As you can see in the examples below, you can define your own Channel types and configure them to fit your needs. The Channel type allows you to configure these features:

typing_events : Controls if typing indicators are shown.
read_events : Controls whether the chat shows how far you’ve read.
connect_events : Determines if events are fired for connecting and disconnecting to a chat.
search : Controls if messages should be searchable.
reactions : If users are allowed to add reactions to messages.
replies : Enables message threads and replies.
mutes : Determines if users are able to mute other users.
push_notifications : If messages are allowed to generate push notifications.
uploads : Allows image and file uploads within messages.
url_enrichment : When enabled, messages containing URLs will be enriched automatically with image and text related to the message. This is disabled by default for the livestream channel type and we do not recommend enabling it for performance reasons.
skip_last_msg_update_for_system_msgs : Allows to not update the last_message_at timestamp of a channel in the case of system messages.
user_message_reminders : Allow users to set reminders for messages More information can be found here
count_messages : Enables message counting on new channels. When enabled the message count will be present in the channel response. More information can be found here
Channel Types Fields
name	type	description	default	optional
name	string	The name of the channel type must be unique per application		
max_message_length	int	The max message length	5,000	✓
typing_events	default	Enable typing events	default	✓
read_events	boolean	Enable read events	true	✓
connect_events	boolean	Enable connect events	true	✓
search	boolean	Enable message search	true	✓
reactions	boolean	Enable message reactions	true	✓
replies	boolean	Enable replies (threads)	true	✓
mutes	boolean	Enable mutes	true	✓
uploads	boolean	Enable file and image upload	true	✓
url_enrichment	boolean	Automatically enrich URLs	true	✓
automod	string	Disabled, simple or AI are valid options for the Automod (AI based moderation is a premium feature)	simple	✓
commands	list of string	The commands that are available on this channel type	[]	✓
push_notifications	boolean	Enable push notifications	true	✓
quotes	boolean	Allow quotes/inline replies	true	✓
skip_last_msg_update_for_system_msgs	string	Allows to not update the last_message_at timestamp of a channel in the case of system messages	false	✓
user_message_reminders	boolean	Allow users to set reminders and bookmarks for messages	false	✓
count_messages	boolean	Enables message counting on new channels	false	✓
You need to use server-side authentication to create, edit, or delete a channel type.

Creating a Channel Type

JavaScript

Python

Ruby

PHP

Java

C#

Go

import { DenyAll, AnyRole } from "stream-chat";
await client.createChannelType({
  name: "public",
  mutes: false,
  reactions: false,
});
If not provided, the permission settings will default to the ones from the built-in “messaging” type.

Please note that applications have a hard limit of 50 channel types. If you need more than this please have a look at the Multi-tenant & Teams section.

List Channel Types
You can retrieve the list of all channel types defined for your application.


JavaScript

PHP

Python

Go

Ruby

Java

C#

const channelTypes = await client.listChannelTypes();
Get a Channel Type
You can retrieve a channel type definition with this endpoint.

Features and commands are also returned by other channel endpoints.


JavaScript

PHP

Python

Go

Ruby

Java

C#

const channelType = await client.getChannelType("public");
Edit a Channel Type
Channel type features, commands and permissions can be changed. Only the fields that must change need to be provided, fields that are not provided to this API will remain unchanged.


JavaScript

PHP

Python

Go

Ruby

Java

C#

const update = await client.updateChannelType("public", {
  replies: false,
  commands: ["all"],
});
Features of a channel can be updated by passing the boolean flags:


JavaScript

PHP

Python

Go

Ruby

Java

C#

const update = await client.updateChannelType("public", {
  typing_events: false,
  read_events: true,
  connect_events: true,
  search: false,
  reactions: true,
  replies: false,
  mutes: true,
});
Settings can also be updated by passing in the desired new values:


JavaScript

PHP

Python

Go

Ruby

Java

C#

const update = await client.updateChannelType("public", {
  automod: "disabled",
  max_message_length: 140,
  commands: ["giphy", "ban"],
});
Remove a Channel Type

JavaScript

PHP

Python

Go

Ruby

Java

C#

const destroy = await client.deleteChannelType("public");
You cannot delete a channel type if there are any active channels of that type.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Multi-Tenant & Teams
Next
Channel-level settings
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Dynamic Partitioning
Dynamic Partitioning
Stream can support millions of watchers in a channel, but sometimes, this can create a lot of noise when many people send messages simultaneously. Dynamic partitioning allows for splitting the channel into virtual partitions where users only interact with users within the same partition. It boosts engagement by grouping users into smaller partitions with balanced capacities according to configurable settings.

Dynamic partitioning is particularly useful in scenarios where a large number of people are engaging in a live event, such as a game, a live stream, or a webinar. With so many messages flooding the channel, it can quickly become overwhelming, making it difficult for meaningful engagement to occur among participants. To address this, dynamic partitioning divides watchers into smaller partitions within the channel, boosting the chances of meaningful and enjoyable interactions without restricting the volume of messages sent.

Dynamic Partitioning is transparent to connected clients, except for receiving fewer messages.

Partition split
System messages are always delivered to all partitions.

Enabling Dynamic Partitioning
This feature is only available on Stream’s Enterprise pricing plans. Request the Stream team to enable this feature for your app by contacting support.

Dynamic partitioning is configured on a channel type level and can be enabled by setting the partition_size to a number for how many people should appear in each partition, such as 100. When enabled, the channel is divided into smaller partitions that all attempt to keep approximately the desired number of users in each partition. When a user sends a message, it is only delivered to other users on the same partition.


JavaScript

await client.createChannelType({
  name: "example",
  partition_size: 100,
});
const channel = client.channel("example", "test", {
  created_by_id: "admin",
});
await channel.create();
The minimum partition size is 10, and there is no maximum. Dynamic partitioning can only be configured from server clients.

Partitions are added and removed automatically, and clients are moved to new partitions as needed. Most clients stay on the same partition during a split, but some are moved to balance partitions. For example, assume 1000 clients are connected, and the target partition size is 100. 1000 users / 100 per partition = 10 partitions. If a new client is connected, we end up with 11 partitions and some existing clients are moved to this partition to keep them balanced at ~91/partition.

Partitions are also removed when a client disconnects so that no partition becomes empty or unbalanced. The system will attempt to keep all partitions at approximately the desired target size.

Partition merge
Updating dynamic partitioning
The partition_size can be changed at any time without impacting existing connected clients. For example, with 5000 connected clients and a partition_size of 100, we have 50 partitions. If the value is changed to 200, the partitions merge to 25 with 200 users each.


JavaScript

await client.updateChannelType("example", {
  partition_size: 200,
});
Disabling dynamic partitioning
To disable dynamic partitioning, update the channel type and set the partition_size to null. All connected clients will now receive all messages.


JavaScript

await client.updateChannelType("example", {
  partition_size: null,
});
Partition TTL
When users connect, they are placed on the same partition as before, if it still exists. This allows users to stay close by and see familiar users. However, sometimes, this is not desired if the chat should feel vibrant with new users. We can use Partition TTL to do this without increasing the partition size. This will move users to a random partition at a set interval. Partition TTL is disabled by default.

Partition randomization with TTL
Partition TTL can be enabled by setting partition_ttl to a value for how frequently partitions should be randomized. The duration is provided as a string, such as 3h, 24h, or 2h30m. Value units are s, m and h. For example, with a value of partition_ttl: "6h", all partitions are randomly shuffled every 6 hours. The minimum value is 1 minute. There is no maximum value.


JavaScript

await client.updateChannelType("example", {
  partition_ttl: "24h",
});
The value can be updated at any time, and it can be disabled by setting the value to null. Updating it (including disabling it) will move any connected users to a new partition.

Caveats
Users may be moved to a new partition at any time. This means a user may reply to a message, but the original author may not receive the reply as they are now in a different partition.

The distribution of the partitions is not perfect by design. For example, if we have a desired size of 100, some partitions may end up with 95 users, and others may end up with 105. Partitions will stay within approximately 10% of the desired size.

Reloading the channel’s history will return all messages. If this is not desired, the existing messages should be retained on the client side.

When reconnecting, the client may not end up on the same partition.

Randomizing the partitions with partition_ttl is not guaranteed to happen at a specific time of day ( 24h does not mean every midnight)

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Channel-level settings
Next
Creating Channels
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Creating Channels
Creating Channels
Both channel channel.create and channel.watch methods ensure that a channel exists and create one otherwise. If all you need is to ensure that a channel exists, you can use channel.create. This is allowed server-side and client-side, however, is more commonly used server-side. Client-side integrations favor channel.watch as it both creates and watches the channel in one call. See: Watching A Channel

Channels are unique either by specifying a channel ID or list of members in the create request.

1. Creating a Channel Using a Channel Id
This is the best approach if you already have some sort of object in your database that the channel is associated with. As an example, if you’re building a live-streaming service like Twitch you have a channel for every streamer in your database.


Kotlin

JavaScript

Swift

Dart

Node

Ruby

Unreal

Python

PHP

C#

Go

Unity

Java

const channel = client.channel("messaging", "travel", {
  name: "Awesome channel about traveling",
});
// Here, 'travel' will be the channel ID
await channel.create();
2. Creating a Channel for a List of Members - distinct channels
Channels can be used to create conversations between users. In most cases, you want conversations to be unique and make sure that a group of users have only one channel. These are also referred to as ‘distinct channels’.

You can achieve this by leaving the channel ID empty and providing channel type and members. When you do so, the API will ensure that only one channel for the members you specified exists (the order of the members does not matter).

You cannot add members for channels created this way.


Kotlin

JavaScript

Dart

Swift

Node

PHP

Ruby

Unreal

Python

PHP

C#

Go

Unity

Java

const channel = client.channel("messaging", {
  members: ["thierry", "tommaso"],
});
await channel.create();
Channel Data
When you create a channel using one of the above approaches you’ll specify the following fields:

name	type	description	default	optional
type	string	The channel type. Default types are livestream, messaging, team, gaming and commerce. You can also create your own types.	-	
id	string	The channel id (optional). If you don’t specify an ID the ID will be generated based on the list of members. (max length 64 characters)	-	✓
channel data	object	Extra data for the channel. Must not exceed 5KB in size.	default	✓
The channel data can contain as many custom fields as you’d like as long as the total size is below 5KB. Note that you typically upload images to a CDN. So the 5KB limit only applies to the text data specified on the channel. Members is a reserved field, and our UI libraries use name and image to display the channels.

Name	Type	Description
name	string	The channel name. No special meaning, but by default the UI component will try to render this if the property is present.
image	string	The Channel image. Again there is no special meaning but by default, the UI component will try to render this if the property is present.
members	array	The members participating in this Channel. Note that you don’t need to specify members for a live stream or other public chat. You only need to specify the members if you want to limit access of this chat to these members and subscribe them to future updates
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Dynamic Partitioning
Next
Watching a Channel
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Watching a Channel
Watching a Channel
The call to channel.watch does a few different things in one API call:

It creates the channel if it doesn’t exist yet (if this user has the right permissions to create a channel)

It queries the channel state and returns members, watchers and messages

It watches the channel state and tells the server that you want to receive events when anything in this channel changes

To start watching a channel
The examples below show how to watch a channel. Note that you need to be connected as a user before you can watch a channel.


Kotlin

JavaScript

Dart

Swift

Unreal

Unity

Java

const state = await channel.watch();
Response Schema

Name	Type	Description
config	object	The configuration for the channel type.
channel	object	The Channel object.
online	integer	Number of online members.
watchers	object	Users that are watching this channel. Represented as a mapping from the user id to the user object.
members	object	Channel members. Represented as a mapping from the user id to the user object.
read	object	Read messages grouped by user id. Represented as a mapping from the user id to the message object.
Watching a channel only works if you have connected as a user to the chat API

Watchers vs Members
The concepts of watchers vs members can require a bit of clarification:

members : a permanent association between a user and a channel. If the user is online and not watching the channel they will receive a notification event, if they are offline they will receive a push notification.

watchers : the list of watchers is temporary. It’s anyone who is currently watching the channel.

Being able to send messages, and otherwise engage with a channel as a non-member requires certain permissions. For example, we have pre-configured permissions on our livestream channel type to allow non-members to interact, but in the messaging channel type, only members of the channel can interact.

Watching Multiple Channels
The default queryChannels API returns channels and starts watching them. There is no need to also use channel.watch on the channels returned from queryChannels


Kotlin

JavaScript

Dart

Swift

Unreal

Unity

Java

// first let’s create a filter to make messaging channels that include a specific user
const filter = { type: "messaging", members: { $in: [user_id] } };
// we can also define a sort order of most recent messages first
const sort = { last_message_at: -1 };
// finally, we can query for those channels, automatically watching them for the
// currently connected user
const channels = await client.queryChannels(filter, sort, { watch: true });
Stop Watching a Channel
To stop receiving channel events:


Kotlin

JavaScript

Dart

Unreal

Unity

Java

Swift

// we can also stop watching a channel
const stopWatching = await channel.stopWatching();
Watcher Count
To get the watcher count of a channel:


Kotlin

JavaScript

Dart

Swift

Unreal

Unity

Java

// filter on a specific channel cid
const filter = { cid: channelCID };
// sort by most recent messages first
const sort = { last_message_at: -1 };
// retrieve our channels
const channels = await client.queryChannels(filter, sort);
// each channel object has a state collection with a watcher_count property
return channels[0].state.watcher_count;
Paginating Channel Watchers with channel.query

Kotlin

JavaScript

Dart

Swift

Unreal

Unity

Java

// create a new channel of type “livestream” with name “watch-this-channel”
const channel = client.channel("livestream", "watch-this-channel", {});
// now query the newly created channel for watchers, retrieving the first 5
const result = await channel.query({
  watchers: { limit: 5, offset: 0 },
});
return result.watchers;
The maximum limit that can be used is 300, and the maximum offset that can be used is 10 000.

Listening to Changes in Watchers
A user already watching the channel can listen to users starting and stopping watching the channel with the realtime events:


Kotlin

JavaScript

Dart

Swift

Unreal

Unity

Java

const channel = client.channel("livestream", "watch-this-channel", {});
channel.watch();
channel.on("user.watching.start", (event) => {
  // handle watch started event
  console.log(`${event.user.id} started watching`);
});
channel.on("user.watching.stop", (event) => {
  // handle watch stopped event
  console.log(`${event.user.id} stopped watching`);
});
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Creating Channels
Next
Updating a Channel
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Updating a Channel
Updating a Channel
There are two ways to update a channel using the Stream API - a partial or full update. A partial update will retain any custom key-value data, whereas a complete update is going to remove any that are unspecified in the API request.

Partial Update
A partial update can be used to set and unset specific fields when it is necessary to retain additional custom data fields on the object. AKA a patch style update.


Kotlin

JavaScript

Dart

Python

PHP

C#

Unreal

Go

Ruby

Unity

Java

Swift

// Here's a channel with some custom field data that might be useful
const channel = client.channel(type, id, {
  source: "user",
  source_detail: { user_id: 123 },
  channel_detail: { topic: "Plants and Animals", rating: "pg" },
});
// let's change the source of this channel
await channel.updatePartial({ set: { source: "system" } });
// since it's system generated we no longer need source_detail
await channel.updatePartial({ unset: ["source_detail"] });
// and finally update one of the nested fields in the channel_detail
await channel.updatePartial({ set: { "channel_detail.topic": "Nature" } });
// and maybe we decide we no longer need a rating
await channel.updatePartial({ unset: ["channel_detail.rating"] });
Full Update (overwrite)
The update function updates all of the channel data. Any data that is present on the channel and not included in a full update will be deleted.


Kotlin

JavaScript

Dart

PHP

Swift

Python

Unreal

C#

Go

Ruby

Unity

Java

const update = await channel.update(
  {
    name: "myspecialchannel",
    color: "green",
  },
  { text: "Thierry changed the channel color to green", user_id: "Thierry" },
);
Request Params
Name	Type	Description	Optional
channel data	object	Object with the new channel information. One special field is “frozen”. Setting this field to true will freeze the channel. Read more about freezing channels in “Freezing Channels”	
text	object	Message object allowing you to show a system message in the Channel that something changed.	Yes
Updating a channel using these methods cannot be used to add or remove members. For this, you must use specific methods for adding/removing members, more information can be found here.

Archiving a channel
A member in a channel can mark the channel as archived. The archival state is stored for this member, so it doesn’t affect anybody else. From an API point of view, an archived channel is the same as another channel, but the user interface may render an archived channel in a different way. When a channel is archived, the current date is recorded and this is returned as archived_at in the response.

When querying channels, the query can specify that archived channels should be excluded. The query can also specify only archived channels.


Kotlin

JavaScript

Dart

Go

Php

Python

Ruby

Java

Swift

C#

// Get a channel
const channel = client.channel("messaging", "example");
// Archive the channel.
await channel.archive();
// Query for channels that are not archived.
const resp = await client.queryChannels({ archived: false });
await channel.unarchive();
Pinning a channel
Pinning works very similar to archiving. A client can mark a channel as pinned, which can be used to render it differently in the UI. When a channel is pinned, the response contains a pinned_at timestamp.

Like archiving, it’s possible to query channels with a specific pinned state. It is also possible to sort channels by pin, such as returning pinned channels first.


Kotlin

JavaScript

Dart

Go

Php

Python

Ruby

Java

Swift

C#

// Get a channel
const channel = client.channel("messaging", "example");
// Pin the channel.
await channel.pin();
// Query for channels that are pinned.
const resp = await client.queryChannels({ pinned: true });
// Query for channels for specific members and show pinned first.
const resp = await client.queryChannels(
  { members: { $in: ["amy", "ben"] } },
  { pinned_at: -1 },
);
await channel.unpin();
Global archiving or pinning
Channels are archived or pinned for a specific member. If the channel should instead be archived or pinned for all users, the this can be stored as custom data in the channel itself. The value cannot collide with the existing fields, so use a value such as globally_archived: true.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Watching a Channel
Next
Updating Channel Members
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Updating Channel Members
Updating Channel Members
Adding & Removing Channel Members
Using the addMembers() method adds the given users as members, while removeMembers() removes them.


Kotlin

JavaScript

Dart

PHP

Swift

Go

Unreal

Python

C#

Ruby

Java

Unity

await channel.addMembers(["thierry", "josh"]);
await channel.removeMembers(["tommaso"]);
// Add user to the channel with role set
await channel.addMembers([
  { user_id: "james_bond", channel_role: "channel_moderator" },
]);
// Add new channel member with custom data
await channel.addMembers([{ user_id: "james_bond", code_name: "007" }]);
Note: You can only add/remove up to 100 members at once.

Members can also be added while creating the channel.


Kotlin

JavaScript

Swift

const channel = client.channel('messaging', randomID, {
  members: [
    { user_id: "james_bond", code_name: "007" },
    { user_id: "alec_trevelyan", code_name: "006" },
    { user_id: "bill_fairbanks", code_name: "002" },
});
await channel.create();
Message parameter
You can optionally include a message object that client-side SDKs will use to populate a system message. This works for both add and remove members


Kotlin

JavaScript

Go

Python

PHP

C#

Ruby

Java

Unreal

Unity

Swift

// using client-side client
await channel.addMembers(["tommaso"], { text: "Tommaso joined the channel." });
// using server-side client
await channel.addMembers(["tommaso"], {
  text: "Tommaso joined the channel.",
  user_id: "tommaso",
});
Hide history
When members join a channel you can specify if they have access to the history or not. The history will be shown by default, set true to hide_history parameter to hide it for new members.


Kotlin

JavaScript

Go

Python

PHP

C#

Ruby

Java

Unity

Swift

await channel.addMembers(["thierry"], undefined, { hide_history: true });
Alternatively, hide_history_before can be used to hide any history before a given timestamp while giving members access to later messages. The value must be a timestamp in the past in RFC 3339 format. If both parameters are defined, hide_history_before takes precedence over hide_history.


JavaScript

Go

Python

PHP

C#

Ruby

Java

const cutoff = new Date();
cutoff.setDate(date.getDate() - 7); // Last 7 days
await channel.addMembers(["thierry"], undefined, {
  hide_history_before: cutoff.toISOString(),
});
Leaving a channel
It is possible for user to leave the channel without moderator-level permissions. Make sure channel members have Leave Own Channel permission.


Kotlin

JavaScript

Go

Python

PHP

C#

Ruby

Java

Unreal

Unity

Swift

// remove own channel membership
await channel.removeMembers(["my_user_id"]);
You can familiarize yourself with all permissions in Permissions section

Adding & Removing Moderators to a Channel
Using the addModerators() method adds the given users as moderators (or updates their role to moderator if already members), while demoteModerators() removes the moderator status.


JavaScript

Python

Ruby

PHP

Java

C#

Go

Unity

await channel.addModerators(["thierry", "josh"]);
await channel.demoteModerators(["tommaso"]);
These operations can only be performed server-side and up to 100 moderators can be added or removed at once.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Updating a Channel
Next
Querying Channels
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Querying Channels
Querying Channels
If you’re building a similar application to Facebook Messenger or Intercom, you’ll want to show a list of Channels. The Chat API supports MongoDB style queries to make this easy to implement.

You can query channels based on built-in fields. You can find the complete list of supported operators in the query syntax section of the docs.

Multiple filters can be combined, but more complex filters can increase the latency of this API. Reach out to support if you have any doubts about your query filter or logic.

As an example, let’s say that you want to query the last conversations I participated in sorted by last_message_at .

Stream Chat does not run MongoDB on the backend, only a subset of the query options are available.

Here’s an example of how you can query the list of channels:


Kotlin

JavaScript

Dart

PHP

Swift

Unreal

Go

Python

Ruby

C#

Unity

Java

const filter = { type: 'messaging', members: { $in: ['thierry'] } };
const sort = [{ last_message_at: -1 }];
const channels = await chatClient.queryChannels(filter, sort, {
  watch: true, // this is the default
  state: true,
});
channels.map((channel) => {
    console.log(channel.data.name, channel.cid)
  })
}
Query Parameters
name	type	description	default	optional
filters	object	The query filters to use on built-in channel fields, see next section for reference.	{}	
sort	object or array of objects	The sorting used for the channels matching the filters. Sorting is based on field and direction, multiple sorting options can be provided. You can sort based on last_updated, last_message_at,updated_at,created_at,member_count, unread_count or has_unread (unread status). Direction can be ascending (1) or descending (-1)	[{last_updated: -1}]	
options	object	Query options. See below.	{}	
Some languages does not guarantee field order in objects or maps. That’s why using array of single key objects is necessary

By default when query channels does not have any filter and it will match all channels on your application. While this might be OK during development, you most likely want to have at least some basic filtering.

At a minimum, the filter should include members: { $in: [userID] } .

The query channels endpoint will only return channels that the user can read, you should make sure that the query uses a filter that includes such logic. For example: messaging channels are readable only to their members, such requirement can be included in the query filter (see below).

Common filters by use-case
Messaging and Team
On messaging and team applications you normally have users added to channels as a member. A good starting point is to use this filter to show the channels the user is participating.


Kotlin

JavaScript

Dart

PHP

Swift

Unreal

Go

Python

Ruby

C#

Java

Unity

const filter = { members: { $in: ["thierry"] } };
Support
On a support chat, you probably want to attach additional information to channels such as the support agent handling the case and other information regarding the status of the support case (ie. open, pending, solved).


Kotlin

JavaScript

Dart

PHP

Swift

Unreal

Go

Python

Ruby

C#

Java

Unity

const filter = {
  agent_id: `${user.Id}`,
  status: { $in: ["pending", "open", "new"] },
};
Channel Queryable Built-In Fields
To learn more about the supported query operators themselves, please see: Query Syntax Operators.

The following channel fields can be used to filter your query results.

Name	Type	Description	Supported Operators	EXAMPLE
frozen	boolean	channel frozen status	$eq	false
type	string or list of string	the type of channel	$in, $eq	messaging
id	string or list of string	the ID of the channel	$in, $eq	general
cid	string or list of string	the full channel ID	$in, $eq	messaging:general
members	string or list of string	the list of user IDs of the channel members	$in, $eq	marcelo or [thierry, marcelo]
invite	string, must be one of these values: (pending, accepted, rejected)	the status of the invite	$eq	pending
joined	boolean	whether current user is joined the channel or not (through invite or directly)	$eq	true
muted	boolean	whether the current user has muted the channel	$eq	true
member.user.name	string	the ‘name’ property of a user who is a member of the channel	$autocomplete, $eq	marc
created_by_id	string	the id of the user that created the channel	$eq	marcelo
hidden	boolean	whether the current user has hidden the channel	$eq	false
last_message_at	string, must be formatted as an RFC3339 timestamp	the time of the last message in the channel	$eq, $gt, $lt, $gte, $lte, $exists	2021-01-15T09:30:20.45Z
member_count	integer	the number of members in the channel	$eq, $gt, $lt, $gte, $lte	5
created_at	string, must be formatted as an RFC3339 timestamp	the time the channel was created	$eq, $gt, $lt, $gte, $lte $exists	2021-01-15T09:30:20.45Z
updated_at	string, must be formatted as an RFC3339 timestamp	the time the channel was updated	$eq, $gt, $lt, $gte, $lte	2021-01-15T09:30:20.45Z
team	string	the team associated with the channel	$eq	stream
last_updated	string, must be formatted as an RFC3339 timestamp	the time of the last message in the channel. If the channel has no messages, then the time the channel was created	$eq, $gt, $lt, $gte, $lte	2021-01-15T09:30:20.45Z
disabled	boolean	Whether the channel is disabled or not.	$eq	false
has_unread	boolean	Retrieve channels where the user has an unread message. Only “true” is supported, up to 100 channels	true	true
app_banned	string	Filter channels based on application-banned users. Only applies to channels with exactly 2 members.	excluded, only	excluded
Querying by the channel Identifier should be done using the cid field as far as possible to optimize API performance. As the full channel ID, cid is indexed everywhere in Stream database where id is not.

The app_banned filter only works on direct message channels with exactly 2 members. When used, the query will only return channels with exactly 2 members, and other filters will be applied to this subset of channels.

Query Options
name	type	description	default	optional
state	boolean	if true returns the Channel state	true	✓
watch	boolean	if true listen to changes to this Channel in real time.	true	✓
limit	integer	The number of channels to return (max is 30)	10	✓
offset	integer	The offset (max is 1000)	0	✓
message_limit	integer	How many messages should be included to each channel (Max 300)	25	✓
member_limit	integer	How many members should be included for each channel (Max 100)	100	✓
Query channels allows you to retrieve channels and start watching them at same time using the watch parameter set to true.

Response
The result of querying a channel is a list of ChannelState objects which include all the required information to render them without any additional API call.

ChannelState Response
Field Name	Description
channel	The data for this channel
messages	The most recent messages for this channel (see message_limit option)
watcher_count	How many users are currently watching the channel
read	The read state for the members, up to 100 members, ordered by the most recent added, the current user’s read state is always included
members	The list of members, up to 100 ordered by the most recent added
pinned_messages	Up to 10 most recent pinned messages
Response
Pagination
Query channel requests can be paginated similar to how you paginate on other calls. Here’s a short example:


Kotlin

JavaScript

Dart

PHP

Swift

Unreal

Go

Python

Ruby

C#

Java

Unity

// retrieve 20 channels with Thierry as a member and skip first 10
const filter = { members: { $in: ["thierry"] } };
const sort = { last_message_at: -1 };
const channels = await authClient.queryChannels(filter, sort, {
  limit: 20,
  offset: 10,
});
It is important to note that your filter should include, at the very least {members: {$in: [userID]} or pagination could break.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Updating Channel Members
Next
Querying Members
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Querying Members
Querying Members
The queryMembers endpoint allows you to list and paginate members for a channel. The endpoint supports filtering on numerous criteria to efficiently return member information. This endpoint is useful for channels that have large lists of members and you want to search members or if you want to display the full list of members for a channel.

Pagination and ordering
By default members are ordered from oldest to newest and can be paginated using offset-based pagination or by created_at or user_id fields.

Pagination by offset is the simplest to implement but it can lead to incorrect results if the list of members changes while you are paginating.

The recommended approach is to sort by “created_at” or by “user_id”.


Kotlin

JavaScript

Swift

Python

Java

Ruby

C#

PHP

Go

Unreal

Unity

await channel.queryMembers({}, sort, {});
// returns up to 100 members ordered by created_at descending
let sort = { created_at: -1 };
await channel.queryMembers({}, sort, {});
// returns up to 100 members ordered by user_id descending
sort = { user_id: -1 };
await channel.queryMembers({}, sort, {});
// paginate by user_id in descending order
sort = { user_id: 1 };
let options = { user_id_lt: lastMember.user_id };
await channel.queryMembers({}, sort, options);
// paginate by created at in ascending order
sort = { created_at: -1 };
options = { created_at_before: lastMember.created_at };
await channel.queryMembers({}, sort, options);
// paginate using offset
options = { offset: 20 };
await channel.queryMembers({}, sort, {});
Stream Chat does not run MongoDB on the backend, only a subset of the query options are available.

Here’s some example of how you can query the list of members:


Kotlin

JavaScript

Swift

Python

Dart

Unreal

Ruby

C#

PHP

Go

Java

Unity

// query members by user.name
channel.queryMembers({'name':'tommaso'})
// autocomplete members by user name
channel.queryMembers({name:{"$autocomplete":'tomm'}})
// query member by id
channel.queryMembers({user_id:'tommaso'})
// query multiple members by id
channel.queryMembers({user_id:{'$in:'['tommaso','thierry']}})
// query channel moderators
channel.queryMembers({is_moderator:true})
// query for banned members in channel
channel.queryMembers({banned:true})
// query members with pending invites
channel.queryMembers({invite:'pending'})
// query members who joined the channel directly or accepted an invite
channel.queryMembers({joined: true})
// query members who have rejected invite or have pending invite
channel.queryMembers({joined: false}
// query all the members
channel.queryMembers({})
// order results by member created at descending
channel.queryMembers({}, {created_at:-1})
// you can also query members by custom data
client.queryMembers({ 'user.email':'awesome@getstream.io' })
client.queryMembers({ 'subscription':'gold_plan' })
Query Parameters
name	type	description	default	optional
filters	object	The query filters to use. You can query on any of the custom fields defined above	{}	
sort	object	the sort parameters	{ created_at:1}	✓
options	object	pagination options	{ limit:100, offset:0}	✓
By default when query members does not have any filter and it will match all members on your channel.

Member Queryable Built-In Fields
The following fields can be used to filter your query results

Name	Type	Description	supported operators	Example
id	string	the id of the user	$eq $in	tom
name	string	the name of the user	$eq, $in, $autocomplete, $q	Tommaso
channel_role	string	the member role	$eq	channel_moderator
banned	boolean	the banned status	$eq	false
invite	string, must be one of these values: (pending, accepted, rejected)	the status of the invite	$eq	pending
joined	boolean	whether member is joined the channel or not	$eq	true
created_at	string, must be formatted as an RFC3339 timestamp	the time that the member was created	$eq, $gt, $gte, $lt, $lte	2021-01-15T09:30:20.45Z
updated_at	string, must be formatted as an RFC3339 timestamp	the time the member was last updated	$eq, $gt, $gte, $lt, $lte	2021-01-15T09:30:20.45Z
last_active	string, must be formatted as an RFC3339 timestamp	the time the user was last active	$eq, $gt, $gte, $lt, $lte	2021-01-15T09:30:20.45Z
cid	string	the cid of the channel that the user is a member of	$eq	messaging:general
user.email	string	the ‘email’ property of the user	$eq, $in, $autcomplete	user@example.com
Also, you can pass any field available in the custom data.

Query Options
name	type	description	default	optional
limit	integer	The number of members to return (max is 100)	100	✓
offset	integer	The offset (max is 1000)	0	✓
user_id_lt	string	Pagination option: excludes members with ID greater or equal the value	-	✓
user_id_lte	string	Pagination option: excludes members with ID greater than the value	-	✓
user_id_gt	string	Pagination option: excludes members with ID less or equal the value	-	✓
user_id_gte	string	Pagination option: excludes members with ID less than the value	-	✓
created_at_after	string	Pagination option: select members created after the date (RFC399)	-	✓
created_at_before	string	Pagination option: select members created before the date (RFC399)	-	✓
created_at_before_or_equal	string	Pagination option: select members created before or equal the date (RFC399)	-	✓
created_at_after_or_equal	string	Pagination option: select members created after or equal the date (RFC399)	-	✓
Response
Field Name	Description
members	The list of members matching the query
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Querying Channels
Next
Channel Pagination
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Channel Pagination
Channel Pagination
The channel query endpoint allows you to paginate the list of messages, watchers, and members for one channel. To make sure that you are able to retrieve a consistent list of messages, pagination does not work with simple offset/limit parameters but instead, it relies on passing the ID of the messages from the previous page.

For example: say that you fetched the first 100 messages from a channel and want to load the next 100. To do this you need to make a channel query request and pass the ID of the oldest message if you are paginating in descending order or the ID of the newest message if paginating in ascending order.

Use the id_lt parameter to retrieve messages older than the provided ID and id_gt to retrieve messages newer than the provided ID.

The terms id_lt and id_gt stand for ID less than and ID greater than.

ID-based pagination improves performance and prevents issues related to the list of messages changing while you’re paginating. If needed, you can also use the inclusive versions of those two parameters: id_lte and id_gte .


Kotlin

JavaScript

Dart

PHP

Swift

Python

Ruby

Unreal

C#

Go

Java

Unity

// the id of the last message on the page
const lastMessageId = messages[0].id;
// pick the parts you need; messages, members or watchers
const result = await channel.query({
  messages: { limit: 20, id_lt: lastMessageId },
  members: { limit: 20, offset: 0 },
  watchers: { limit: 20, offset: 0 },
});
// fetch messages around a specific message
const result = await channel.query({
  messages: { limit: 20, id_around: message_id },
});
// fetch more than 100 members
const result = await channel.query({
  state: true,
  members: { limit: 110, offset: 0 },
});
For members and watchers, we use limit and offset parameters. The maximum limit and offset that can be used is 300 and 10000, respectively.

To retrieve more than 100 members in a single query, you must include state as true in your channel query parameters.

Soon we will create friendlier aliases for id_lt and id_gt. Our best candidates are before_id and after_id, let us know if you have any feedback or suggestion!

The maximum number of messages that can be retrieved at once from the API is 300.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Querying Members
Next
Channel Capabilities
© Getstream.io, Inc. All Rights Reserved.
Channel Capabilities
Channel capabilities lets clients understand which features are available. Each channel payload contains the own_capabilities field which is essentially a list of actions that user is allowed to perform.

Channel capabilities are affected by a number of factors including:

User Permissions

Channel Type settings

Channel-level settings

Capabilities is the preferred way of deciding which actions should be available in the user interface.

Please avoid performing comparisons like user.role == 'user' in your client code and rely on Channel Capabilities instead. This makes your code more flexible and adaptive to your app configuration

Channel Capabilities
Name	What it indicates
ban-channel-members	Ability to ban channel members
connect-events	Ability to receive connect events
create-call	Ability to create a call
delete-any-message	Ability to delete any message from the channel
delete-channel	Ability to delete channel
delete-own-message	Ability to delete own messages from the channel
flag-message	Ability to flag a message
freeze-channel	Ability to freeze or unfreeze channel
join-call	Ability to join a call
join-channel	Ability to join channel (add own membership)
leave-channel	Ability to leave channel (remove own membership)
mute-channel	Ability to mute a channel
pin-message	Ability to pin a message
quote-message	Ability to quote a message
read-events	Ability to receive read events
search-messages	Ability to use message search
send-custom-events	Ability to send custom events
send-links	Ability to attach links to messages
send-message	Ability to send a message
send-reaction	Ability to send reactions
send-reply	Ability to reply to a message
send-typing-events	Ability to send typing events
set-channel-cooldown	Ability to enable or disable slow mode
skip-slow-mode	Indicates that the user is allowed to post messages as usual even if the channel is in slow more
slow-mode	Indicates that channel slow mode is active
typing-events	Ability to send and receive typing events
update-any-message	Ability to update any message in the channel
update-channel	Ability to update channel data
update-channel-members	Ability to update channel members
update-own-message	Ability to update own messages in the channel
upload-file	Ability to upload message attachments
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Channel Pagination
Next
Invites
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Invites
Invites
Inviting Users
Stream Chat provides the ability to invite users to a channel. Upon invitation, the end-user will receive a notification that they were invited to the specified channel.

Most of our SDKs have a helper method for member invitation which uses the Update Channel API endpoint.

See the following for an example on how to invite a user by user ID:


Kotlin

JavaScript

PHP

Dart

Swift

Unreal

Python

Ruby

Go

C#

Java

Unity

await channel.inviteMembers(["nick"]);
Accepting an Invite
In order to accept an invite, you must use call the acceptInvite method. The acceptInvite method accepts an object with an optional message property. Please see below for an example of how to call acceptInvite :

The message can be used for system messages for display within the channel (e.g. “Nick joined this channel!”).

Unread counts are not incremented for a channel for which a user is a member of but has a pending invite.


Kotlin

JavaScript

PHP

Dart

Swift

Unreal

C#

Python

Ruby

Go

Java

Unity

// initialize the channel
const channel = client.channel("messaging", "awesome-chat");
// accept the invite
await channel.acceptInvite({
  message: { text: "Nick joined this channel!" },
});
// accept the invite server side
await channel.acceptInvite({ user_id: "nick" });
Rejecting an Invite
To reject an invite, call the rejectInvite method. This method does not require a user ID as it pulls the user ID from the current session in store from the connectUser call.


Kotlin

JavaScript

PHP

Dart

Swift

Unreal

C#

Python

Ruby

Go

Java

Unity

await channel.rejectInvite();
//server side
await channel.rejectInvite({ user_id: "rob" });
Query for Accepted Invites
Querying for accepted invites is done via the queryChannels method. This allows you to return a list of accepted invites with a single call. See below for an example:


Kotlin

JavaScript

PHP

Dart

Swift

Unreal

C#

Python

Ruby

Go

Java

Unity

const invites = await client.queryChannels({
  invite: "accepted",
});
//server side (query invites for user rob)
const invites = await client.queryChannels(
  {
    invite: "accepted",
  },
  {},
  { user_id: "rob" },
);
Query for Rejected Invites
Similar to querying for accepted invites, you can query for rejected invites with queryChannels. See below for an example:


Kotlin

JavaScript

PHP

Dart

Swift

Unreal

C#

Python

Ruby

Go

Java

Unity

const rejected = client.queryChannels({
  invite: "rejected",
});
//server side (query invites for user rob)
const invites = await client.queryChannels(
  {
    invite: "rejected",
  },
  {},
  { user_id: "rob" },
);
Query for Pending Invites
Similar to querying for accepted and rejected invites, you can query for pending invites with queryChannels. See below for an example:


Kotlin

JavaScript

PHP

Dart

Swift

Unreal

C#

Python

Ruby

Go

Java

Unity

const rejected = client.queryChannels({
  invite: "pending",
});
//server side (query invites for user rob)
const invites = await client.queryChannels(
  {
    invite: "pending",
  },
  {},
  { user_id: "rob" },
);
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Channel Capabilities
Next
Muting or Hiding Channels
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Muting or Hiding Channels
Muting or Hiding Channels
Muting Channels
Messages added to a channel will not trigger push notifications, unhide a channel, nor change the unread count for the users that muted it. By default, mutes stay in place indefinitely until the user removes it; however, you can optionally set an expiration time. The list of muted channels and their expiration time is returned when the user connects.


Kotlin

JavaScript

Swift

Dart

Unreal

PHP

Python

Ruby

C#

Go

Java

Unity

const reply = await client.setUser(user, token);
// reply.me.channel_mutes contains the list of channel mutes
console.log(reply.me.channel_mutes);
const channel = client.channel("messaging", "channel-id");
// mute channel for current user
await channel.mute();
// mute channel for a user (server-side)
await channel.mute({ user_id: userId });
// mute a channel for 2 weeks
await channel.mute({ expiration: moment.duration(2, "weeks") });
// mute a channel for 10 seconds
await channel.mute({ expiration: 10000 });
// check if channel is muted
// { muted: true | false, createdAt: Date | null, expiresAt: Date | null}
channel.muteStatus();
Messages added to muted channels do not increase the unread messages count.

Query Muted Channels
Muted channels can be filtered or excluded by using the muted in your query channels filter.


Kotlin

JavaScript

Swift

Dart

Unreal

PHP

Python

Ruby

C#

Go

Java

Unity

// retrieve all channels excluding muted ones
await client.queryChannels({ members: { $in: [userId] }, muted: false });
// retrieve all muted channels
await client.queryChannels({ muted: true });
Remove a Channel Mute
Whenever you need to unmute, you are able to.


Kotlin

JavaScript

Swift

Dart

Unreal

PHP

Python

Ruby

C#

Go

Java

Unity

// unmute channel for current user
await channel.unmute();
// unmute channel for a user (server-side)
await channel.unmute({ user_id: userId });
Hiding a Channel
Hiding a channel will remove it from query channel requests for that user until a new message is added. Please keep in mind that hiding a channel is only available to members of that channel. Hidden channels may still have unread messages and you may wish to mark the channel as read prior to hiding it.

Optionally you can also clear the entire message history of that channel for the user. This way, when a new message is received, it will be the only one present in the channel.


Kotlin

JavaScript

PHP

Dart

Swift

Unreal

PHP

Python

Ruby

C#

Go

Java

Unity

// hides the channel until a new message is added there
await channel.hide();
// hides the channel until a new message is added there. This also clears the history for the user
await channel.hide(null, true);
// shows a previously hidden channel
await channel.show();
You can still retrieve the list of hidden channels using the { "hidden" : true } query parameter.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Invites
Next
Channel members
Chat Messaging
/
Docs
/
React Native
/
Channel members
Channel members
Add channel members
Members can be added to a channel either when creating it or by using the addMembers method.

When creating a channel

JavaScript

Swift

Java

C#

Kotlin

// members can be added by passing an array of user IDs
const channel = client.channel("messaging", randomID, {
  members: ["userid1", "userid2", "userid3"],
});
// or by passing objects
const channel = client.channel("messaging", randomID, {
  members: [
    { user_id: "userid1" },
    { user_id: "userid2" },
    { user_id: "userid3" },
  ],
});
Using addMembers method

JavaScript

Swift

Java

C#

Kotlin

await channel.addMembers(["userid1", "userid2"]);
// you can set channel_role in the meantime
await channel.addMembers([
  { user_id: "userid1", channel_role: "channel_moderator" },
]);
Note: You can only add up to 100 members at once.

Message parameter

You can optionally include a message object to allow client-side SDKs to generate a system message. This feature is available for both adding and removing members.


JavaScript

Swift

Java

C#

Kotlin

await channel.addMembers(["userid1"], { text: "Tommaso joined the channel." });
// using server-side client, you need to specify the sender user_id
await channel.addMembers(["userid1"], {
  text: "Tommaso joined the channel.",
  user_id: "userid2",
});
Hide history

When members join a channel, you can specify whether they have access to the channel’s history.

By default, new members can see the history. To hide it, set the hide_history parameter to true .


JavaScript

Swift

Java

C#

Kotlin

await channel.addMembers(["userid1"], undefined, { hide_history: true });
Channel member custom data
Custom data can be added at the channel member level. Ensure it does not exceed 5KB.


JavaScript

Swift

C#

Kotlin

// add custom data while creating the channel
const channel = client.channel("messaging", randomID, {
  members: [
    { user_id: "userid1", key1: "value1" },
    { user_id: "userid2", key1: "value1" },
    { user_id: "userid3", key2: "value2" },
  ],
});
// add custom data with `addMembers` method
await channel.addMembers([{ user_id: "userid1", key1: "value1" }]);
Remove channel members / Leave a channel

Remove channel members
removeMembers method allows you to remove members from a channel.


JavaScript

Swift

C#

Kotlin

await channel.removeMembers(["userid1", "userid2"]);
Note: You can only remove up to 100 members at once.

Leave a channel
Users can leave a channel without moderator-level permissions.

Ensure channel members have the Leave Own Channel permission enabled.


JavaScript

Swift

C#

Kotlin

// remove own channel membership
await channel.removeMembers(["myuserid"]);
You can familiarize yourself with all permissions in Permissions section

Add / Remove moderators to a channel
Using the addModerators method adds the given users as moderators (or updates their role to moderator if already members), while demoteModerators removes the moderator status.

Add moderators
The addModerators method adds specified users as moderators to a channel. If the users are already members, their role is upgraded to moderator.


JavaScript

C#

await channel.addModerators(["userid1", "userid2"]);
Remove moderators
The demoteModerators method removes the moderator role from specified users.


JavaScript

C#

await channel.demoteModerators(["userid1"]);
These operations can only be performed server-side, and a maximum of 100 moderators can be added or removed at once.

Update channel members
Channel members can be partially updated. Only custom data and channel roles are eligible for modification.

You can set or unset fields, either separately or in the same call.


JavaScript

Swift

Go

Php

Python

Ruby

Java

C#

Kotlin

// set some fields
await channel.updateMemberPartial(
  {
    set: {
      key1: "new value 1",
      key2: "new value 2",
      channel_role: "channel_moderator",
    },
  },
  { userId: "jane" },
);
// unset some fields
await channel.updateMemberPartial(
  {
    unset: ["key1", "key2"],
  },
  { userId: "jane" },
);
// set / unset in the same call
await channel.updateMemberPartial(
  {
    set: {
      key1: "new value 1",
      key2: "new value 2",
    },
    unset: ["key3"],
  },
  { userId: "jane" },
);
Query channel members
The queryMembers endpoint enables listing and paginating channel members. It offers filtering options to efficiently retrieve member information. This feature is particularly useful when you need to search through or display a comprehensive overview of channel membership.

Pagination and ordering
By default, members are ordered from oldest to newest and can be paginated using offset-based pagination or by the created_at or user_id fields.

While pagination by offset is the simplest to implement, it can lead to incorrect results if the list of members changes during pagination.

The recommended approach is to sort created_at or user_id for more reliable results.


JavaScript

Swift

C#

Kotlin

await channel.queryMembers({}, sort, {});
// returns up to 100 members ordered by created_at descending
let sort = { created_at: -1 };
await channel.queryMembers({}, sort, {});
// returns up to 100 members ordered by user_id descending
sort = { user_id: -1 };
await channel.queryMembers({}, sort, {});
// paginate by user_id in descending order
sort = { user_id: 1 };
let options = { user_id_lt: lastMember.user_id };
await channel.queryMembers({}, sort, options);
// paginate by created at in ascending order
sort = { created_at: -1 };
options = { created_at_before: lastMember.created_at };
await channel.queryMembers({}, sort, options);
// paginate using offset
options = { offset: 20 };
await channel.queryMembers({}, sort, {});
Here’s some example of how you can query the list of members:


JavaScript

Swift

C#

Kotlin

// query members by user.name
channel.queryMembers({'name':'tommaso'})
// autocomplete members by user name
channel.queryMembers({name:{"$autocomplete":'tomm'}})
// query member by id
channel.queryMembers({user_id:'tommaso'})
// query multiple members by id
channel.queryMembers({user_id:{'$in:'['tommaso','thierry']}})
// query channel moderators
channel.queryMembers({is_moderator:true})
// query for banned members in channel
channel.queryMembers({banned:true})
// query members with pending invites
channel.queryMembers({invite:'pending'})
// query members who joined the channel directly or accepted an invite
channel.queryMembers({joined: true})
// query members who have rejected invite or have pending invite
channel.queryMembers({joined: false}
// query all the members
channel.queryMembers({})
// order results by member created at descending
channel.queryMembers({}, {created_at:-1})
// query by user.email
client.queryMembers({ 'user.email':'awesome@getstream.io' })
// you can also query members by custom data
// subscription is a custom field
client.queryMembers({ 'subscription':'gold_plan' })
Query Parameters
name	type	description	default	optional
filters	object	Query filters to use. You can query on any of the custom fields defined above	{}	
sort	object	Sort parameters	{ created_at:1 }	✓
options	object	Pagination options	{ limit:100, offset:0 }	✓
By default when query members does not have any filter and it will match all members on your channel.

Member Queryable Built-In Fields
The following fields can be used to filter channel members, along with any custom data associated with them:

Name	Type	Description	Supported operators
id	string	User ID	$eq - $in
name	string	User name	$eq - $in - $autocomplete - $q
channel_role	string	Member role	$eq
banned	boolean	Ban status	$eq
invite	string accepted values: - pending - accepted - rejected	Invite status	$eq
joined	boolean	Whether user joined the channel or not	$eq
created_at	string (RFC3339)	Time when the member was created	$eq - $gt - $gte - $lt - $lte
updated_at	string (RFC3339)	Time when the member was updated	$eq - $gt - $gte - $lt - $lte
last_active	string (RFC3339)	Last time the member was active	$eq - $gt - $gte - $lt - $lte
cid	string	Channel CID	$eq
user.email	string	User’s email property	$eq - $in - $autocomplete
Query options
name	type	description	default	optional
limit	integer	Number of members to return	100	✓
offset	integer	Offset (max is 1000)	0	✓
user_id_lt	string	Pagination option: excludes members with ID greater or equal the value		✓
user_id_lte	string	Pagination option: excludes members with ID greater than the value		✓
user_id_gt	string	Pagination option: excludes members with ID less or equal the value		✓
user_id_gte	string	Pagination option: excludes members with ID less than the value		✓
created_at_after	string	Pagination option: select members created after the date (RFC399)		✓
created_at_before	string	Pagination option: select members created before the date (RFC399)		✓
created_at_before_or_equal	string	Pagination option: select members created before or equal the date (RFC399)		✓
created_at_after_or_equal	string	Pagination option: select members created after or equal the date (RFC399)		✓
Response
Field name	Description
Members	The list of members matching the query
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Muting or Hiding Channels
Next
Disabling Channels
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Disabling Channels
Disabling Channels
Disable a channel
Disable a channel prevents users from viewing or creating messages on that channel. Any client-side read or write operations will results in a 403 Not Allowed error. You can’t fetch the channel client-side, but you can query channels and receive them, you will have to use disabled:false on your filters in order to filter the disabled channels out. The channel remains usable server-side and data can still be exported.

Channels can be re-enabled which restores historical messages and allows creation of new messages again.


JavaScript

PHP

Python

Ruby

Java

C#

Go

Unity

// disable a channel with full update
await channel.update({ disabled: true });
// disable a channel with partial update
await channel.updatePartial({ set: { disabled: true } });
// enable a channel with full update
await channel.update({ disabled: false });
// enable a channel with partial update
await channel.updatePartial({ set: { disabled: false } });
To prevent new messages from being created, while still being able to read previous messages, freeze the channel instead.

Freeze a channel
Freezing a channel will disallow sending new messages and sending / deleting reactions. Sending a message to a frozen channel will return a message of type error. Sending and deleting reactions to frozen channels will result in a 403 Not Allowed error. User roles with the UseFrozenChannel permission are still able to use frozen channels as if they weren’t frozen. By default no user role has the UseFrozenChannel permission.


Kotlin

JavaScript

Swift

PHP

Python

Ruby

Java

C#

Go

Unity

const update = await channel.update(
	{ frozen: true },
	{ text: 'Thierry has frozen the channel', user_id: "Thierry" }
)
const update = await channel.updatePartial(
	{set: {frozen: true}
)
Unfreeze a Channel

Kotlin

JavaScript

Swift

PHP

Python

Ruby

Java

C#

Go

Unity

const update = await channel.update(
  { frozen: false },
  { text: "Thierry has unfrozen the channel", user_id: "Thierry" },
);
Granting the Frozen Channel Permissions
Since by default no role has the UseFrozenChannel permission, you can edit the channel type to grant the permission to a role (this is only allowed via server side API calls). Read more about user permissions here


JavaScript

PHP

Python

Ruby

Go

Java

Unity

const { grants } = await client.getChannelType("messaging");
grants.admin.push("use-frozen-channel");
await client.updateChannelType("messaging", {
  grants: { admin: grants.admin },
});
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Channel members
Next
Deleting Channels
© Getstream.io, Inc. All Rights Reserved.

© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Deleting Channels
Deleting Channels
You can either delete or truncate a channel to remove its contents. For truncation go over to Truncate Channel page.

Deleting a Channel
You can delete a single Channel using the delete method. This marks the channel as deleted and hides all the messages.


Kotlin

JavaScript

PHP

Dart

Swift

Unreal

Ruby

Python

Go

C#

Unity

Java

const destroy = await channel.delete();
If you recreate this channel, it will show up empty. Recovering old messages is not supported. Use the disable method if you want a reversible change.

Deleting Many Channels
You can delete up to 100 channels and optionally all of their messages using this method. This can be a large amount of data to delete, so this endpoint processes asynchronously, meaning responses contain a task ID which can be polled using the getTask endpoint to check status of the deletions. Channels will be soft-deleted immediately so that channels no longer return from queries, but permanently deleting the channel and deleting messages takes longer to process.

By default, messages are soft deleted, which means they are removed from client but are still available via server-side export functions. You can also hard delete messages, which deletes them from everywhere, by setting "hard_delete": true in the request. Messages that have been soft or hard deleted cannot be recovered.

This is currently supported on the following SDK versions (or higher):

Javascript 4.3.0, Python 3.14.0, Ruby 2.12.0, PHP 2.6.0, Go 3.13.0, Java 1.4.0, Unity 2.0.0 and .NET 0.22.0

JavaScript

Go

Python

Ruby

PHP

Java

C#

Unity

Java

// client-side soft delete
const response = await client.deleteChannels([cid1, cid2]);
// client-side hard delete
const response = await client.deleteChannels([cid1, cid2], {
  hard_delete: true,
});
const result = response.result; // holds deletion result
// server-side soft delete
const response = await serverClient.deleteChannels([cid1, cid2]);
// server-side hard delete
const response = await serverClient.deleteChannels([cid1, cid2], {
  hard_delete: true,
});
const result = await serverClient.getTask(response.task_id);
if (result["status"] === "completed") {
  // success!
}
The deleteChannels response contain a taskID which can be polled using the getTask endpoint to check the status of the deletions.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Disabling Channels
Next
Truncate Channel
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Truncate Channel
Truncate Channel
Messages from a channel can be truncated. This will remove all of the messages but not affect the channel data or channel members. If you want to delete both channel and message data then use the Delete Channel method instead.

Truncate channel can be performed client-side or server-side. To use client-side, the user must have the TruncateChannel permission.

On server-side calls, user_id field can be used to identify channel truncator.

The default behaviour is to hide messages when channel is truncated. To permanently delete messages, set the hard_delete option to true. The following fields can be used to truncate a channel:

Type	Description	Optional
truncated_at	Date	To truncate channel up to given time.	✓
user_id	string	User who truncates the channel (server-side call only)	✓
message	object	A system message to be added via truncation.	✓
skip_push	bool	Don’t send a push notification for system message.	✓
hard_delete	bool	True if truncation should delete messages instead of hiding	✓

Kotlin

JavaScript

Python

C#

Ruby

PHP

Go

Swift

Unity

Java

Unreal

await channel.truncate();
// Or with parameters:
await channel.truncate({
 'hard_delete': true,
 'skip_push': false,
 'message': {
  'text': 'Dear Everyone. The channel has been truncated.'
  'user_id': user['id']
 }
});
// Setting user_id server side:
await channel.truncate({
 'user_id': user['id']
 });
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Deleting Channels
Next
Throttling & Slow mode
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Throttling & Slow mode
Throttling & Slow mode
Throttling & Slow Mode
Stream’s APIs for activity feeds and chat are use by over a billion end users. From a chat API perspective it’s hard to run into limits. One thing to be careful with is the performance of the chat when many users participate in a single channel. For live events or concerts, you can sometimes have so many users, that the sheer volume of messages overloads the browser or mobile device. This can cause the UI to freeze, high CPU usage, and degraded user experience. Stream offers 3 features to help with this:

Channel Slow Mode

Automatic feature Throttling

Message Throttling

Channel Slow Mode
Slow mode helps reduce noise on a channel by limiting users to a maximum of 1 message per cooldown interval.

The cooldown interval is configurable and can be anything between 1 and 120 seconds. For instance, if you enable slow mode and set the cooldown interval to 30 seconds a user will be able to post at most 1 message every 30 seconds.

Moderators, admins and server-side API calls are not restricted by the cooldown period and can post messages as usual.

Slow mode is disabled by default and can be enabled/disabled via the Dashboard, using the Chat Explorer:


It can also be enabled/disabled by admins and moderators via SDK.


Kotlin

JavaScript

Swift

Unreal

C#

PHP

Python

Ruby

Go

Unity

Java

// enable slow mode and set cooldown to 1s
await channel.enableSlowMode(1);
// increase cooldown to 30s
await channel.enableSlowMode(30);
// disable slow mode
await channel.disableSlowMode();
When a user posts a message during the cooldown period, the API returns an error message. You can avoid hitting the APIs and instead show such limitation on the send message UI directly. When slow mode is enabled, channels include a cooldown field containing the current cooldown period in seconds.


Kotlin

JavaScript

Swift

Unreal

Unity

Java

const p = channel.sendMessage(msg);
if (channel.data.cooldown != null && channel.data.cooldown > 0) {
  p.then(() => {
    // first lock the UI so that the user is aware of the cooldown
    disableSendMessageUI();
    // restore the UI after the cooldown is finished
    setTimeout(enableSendMessageUI, channel.data.cooldown);
  });
}
await p;
Automatic Feature Throttling
When a channel has more than 100 active watchers Stream Chat automatically toggles off some features. This is to avoid performance degradation for end-users. Processing large amount of events can potentially increase CPU and memory usage on mobile and web apps.

Read events and typing indicator events are discarded

Watcher start/stop events are only sent once every 5 seconds

Message throttling
Message throttling that protects the client from message flooding. Chat clients will receive up to 5 messages per second and the API servers will allow small surges of messages to be delivered even if that means exceeding the 5 msg/s rate.

Here is an example of how message throttling works:


In this example, the client will receive several more messages above the 5/s limit (the yellow bar), and once this burst credit is over, the client will stop receiving more than 5 messages per second. The burst credit is set to 10 messages on an 8 seconds rolling window.

If you are on an Enterprise Plan, message throttling can be disabled or increased for your application by our support team

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Truncate Channel
Next
Channel Message Count
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Channel Message Count
Channel Message Count
Message counting
Stream Chat can keep track of the number of messages in a channel. This is useful for displaying message counts in your UI.

Message counting is disabled by default and can be enabled on a channel type level by setting the count_messages option to true when creating or updating a channel type.

Message counting only works on newly created channels. Existing channels will not have their message count updated when this feature is enabled.

Enabling message counting

JavaScript

Python

Ruby

PHP

Java

C#

Go

// Create a new channel type with message counting enabled
await client.createChannelType({
  name: "public",
  count_messages: true,
});
Retrieving message count
When message counting is enabled for a channel type, the message count can be retrieved from the channel object.

When you query or watch a channel, the message count will be available in the message_count field of the channel object.

When the `count_messages` setting is enabled for a channel and messages are added or deleted, every event generated as a result of those operations (e.g: `message.new` or `message.deleted`) will include the updated count in the `channel_message_count` field.

Kotlin

JavaScript

Swift

Dart

Node

Ruby

Unreal

Python

PHP

C#

Go

Unity

Java

const channel = client.channel("messaging", "general");
await channel.watch();
console.log(channel.state.channel.message_count);
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Throttling & Slow mode
Next
Messages Overview
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Messages Overview
Messages Overview
Let’s dive right into it, the example below shows how to send a simple message using Stream:


Kotlin

JavaScript

Swift

Dart

PHP

Python

Go

Unreal

C#

Ruby

Unity

Java

const message = await channel.sendMessage({
  text: "@Josh I told them I was pesca-pescatarian. Which is one who eats solely fish who eat other fish.",
});
Note how server side SDKs require that you specify user_id to indicate who is sending the message. You can add custom fields to both the message and the attachments. There’s a 5KB limit for the custom fields. File uploads are uploaded to the CDN so don’t count towards this 5KB limit.

name	type	description	default	optional
text	string	The text of the chat message (Stream chat supports markdown and automatically enriches URLs).		✓
attachments	array	A list of attachments (audio, videos, images, and text). Max is 30 attachments per message. The total combined attachment size can’t exceed 5KB.		
user_id	object	This value is automatically set in client-side mode. You only need to send this value when using the server-side APIs.		✓
mentioned_users	array	A list of users mentioned in the message. You send this as a list of user IDs and receive back the full user data.		
message custom data	object	Extra data for the message. Must not exceed 5KB in size.		
skip_push	bool	Do not send a push notification.	false	✓
restricted_visibility	bool	Send the message only to particular channel members, represented with their user ids.		✓
Complex Example
A more complex example for creating a message is shown below:


Kotlin

JavaScript

Swift

Dart

PHP

Python

Go

Unreal

Ruby

C#

Java

Unity

const message = await channel.sendMessage(
  {
    text: "@Josh I told them I was pesca-pescatarian. Which is one who eats solely fish who eat other fish.",
    attachments: [
      {
        type: "image",
        asset_url: "https://bit.ly/2K74TaG",
        thumb_url: "https://bit.ly/2Uumxti",
        myCustomField: 123,
      },
    ],
    mentioned_users: [josh.id],
    anotherCustomField: 234,
  },
  { skip_push: true },
);
mentioned_users field must contain a maximum of 25 items.

By default Stream’s UI components support the following attachment types:

Audio
Video
Image
Text
You can specify different types as long as you implement the frontend rendering logic to handle them. Common use cases include:

Embedding products (photos, descriptions, outbound links, etc.)
Sharing of a users location
The React tutorial for Stream Chat explains how to customize the Attachment component.

Get a Message
You can get a single message by its ID using the getMessage call:


Kotlin

JavaScript

Swift

Dart

PHP

Python

Go

Unreal

Ruby

C#

Unity

Java

await client.getMessage(messageID);
//if a message was soft-deleted it returns the original message
await serverClient.getMessage(messageID, { show_deleted_message: true });
Get a Message Options
name	type	description	default	optional
show_deleted_message	boolean	if true, returns the original message	false	✓
show_deleted_message is exposed for server-side calls only.

Update a Message
You can edit a message by calling updateMessage and including a message with an ID – the ID field is required when editing a message:


Kotlin

JavaScript

Swift

Dart

PHP

Python

Go

Unreal

Ruby

C#

Unity

Java

const message = { id: 123, text: "the edited version of my text" };
const update = await client.updateMessage(message);
Partial Update
A partial update can be used to set and unset specific fields when it is necessary to retain additional data fields on the object. AKA a patch style update.


Kotlin

JavaScript

Java

PHP

Python

Go

Ruby

C#

Unity

let originalMessage = (
  await channel.sendMessage({
    text: "this message is about to be partially updated",
    color: "red",
    details: {
      status: "pending",
    },
  })
).message;
// partial update message text
const text = "the text was partial updated";
const updated = await client.partialUpdateMessage(originalMessage.id, {
  set: {
    text,
  },
});
// unset color property
const updated = await client.partialUpdateMessage(originalMessage.id, {
  unset: ["color"],
});
// set nested property
const updated = await client.partialUpdateMessage(originalMessage.id, {
  set: {
    "details.status": "complete",
  },
});
Delete A Message
You can delete a message by calling deleteMessage and including a message with an ID. Messages can be soft deleted, hard deleted, or deleted for the current user only (delete for me). Unless specified via the hard or delete_for_me parameter, messages are soft deleted. Be aware that deleting a message doesn’t delete its attachments. See the docs for more information on deleting attachments.

Hard delete and “delete for me” are mutually exclusive options.


Kotlin

JavaScript

Swift

Dart

PHP

Python

Go

Unreal

Ruby

C#

Unity

Java

await client.deleteMessage(messageID);
// hard delete the message
await client.deleteMessage(messageID, true);
// or hard delete the message with options object
await client.deleteMessage(messageID, { hardDelete: true });
// delete for me supported only with options object
await client.deleteMessage(messageID, { deleteForMe: true });

Soft delete
Can be done client-side by users

Message is still returned in the message list and all its data is kept as it is

Message type is set to “deleted”

Reactions and replies are kept in place

Can be undeleted

Hard delete
Can be done client-side by users but be cautious this action is not recoverable

The message is removed from the channel and its data is wiped

All reactions are deleted

All replies and their reactions are deleted

Delete for me
Can be done client-side by users

Users can delete any message for themselves, regardless of who sent it

The message is marked as deleted only for the current user; other channel members are not affected

Message type is set to “deleted” with deleted_for_me flag set to true

Cannot be combined with hard delete

Limited to 100 messages per user per channel (contact support to increase this limit)

By default messages are soft deleted, this is a great way to keep the channel history consistent.

Undelete a message
A message that was soft-deleted can be undeleted. This is only allowed for server-side clients. The userID specifies the user that undeleted the message, which can be used for auditing purposes.

Messages can be undeleted if:

The message was soft-deleted

The channel has not been deleted

It is not a reply to a deleted message. If it is, the parent must be undeleted first

The user that undeletes the message is valid


JavaScript

PHP

Python

Ruby

await client.undeleteMessage(messageID, userID);
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Channel Message Count
Next
Message Format
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Message Format
Message Format
When you post a message on a Channel, there are a few things that happen on the server:

The text markdown format is parsed.
The first URL found in message.text is enriched, and additional information is added automatically. This gives you a preview of the images, videos, etc. from the open-graph data on the associated page.
Any slash commands such as /giphy, /ban, /flag, etc. are handled.

Attachment Format
Messages containing URLs will have a generated attachment with the following structure:

name	type	description	default	optional
type	string	The attachment type based on the URL resource. This can be: audio, image or video		✓
author_name	string	The name of the author.		✓
title	string	The attachment title.		✓
title_link	string	The link to which the attachment message points to.		✓
text	string	The attachment text. It will be displayed in the channel next to the original message.		✓
image_url	string	The URL to the attached image. This is present for URL pointing to an image article (eg. Unsplash)		✓
thumb_url	string	The URL to the attached file thumbnail. You can use this to represent the attached link.		✓
asset_url	string	The URL to the audio, video or image related to the URL.		✓
og_scrape_url	string	The original URL that was used to scrape this attachment.		✓
Open Graph Scraper
Our scraper uses the following user agent, as well as the latest desktop and mobile user agents: getstream.io/opengraph-bot facebookexternalhit/1.1 (+http://www.facebook.com/externalhit_uatext.php) If you plan to scrape any links to websites you can control, please ensure that this user agent isn’t blocked and returns valid opengraph data, for the best results.

Below is an example of URL enrichment as well as the resulting message structure:


Kotlin

JavaScript

Swift

PHP

Dart

Unreal

Python

Ruby

Go

C#

Java

Unity

const response = await channel.sendMessage({
  text: "Check this bear out https://imgur.com/r/bears/4zmGbMN",
});

None

{
 "id": "thierry-5e9619ec-1a0d-443b-ab26-c597ed7af3d0",
 "text": "Check this bear out https://imgur.com/r/bears/4zmGbMN",
 "html": "<p>Check this bear out <a href=\"https://imgur.com/r/bears/4zmGbMN\" rel=\"nofollow\">https://imgur.com/r/bears/4zmGbMN</a></p>\n",
 "type": "regular",
 "user": {
  "id": "thierry",
  "role": "user",
  "created_at": "2019-04-03T14:42:47.087869Z",
  "updated_at": "2019-04-16T09:20:03.982283Z",
  "last_active": "2019-04-16T11:23:51.168113408+02:00",
  "online": true
 },
 "attachments": [
  {
   "type": "image",
   "author_name": "Imgur",
   "title": "An update: Dushi made it safe to Bear Sanctuary Müritz",
   "title_link": "https://imgur.com/4zmGbMN",
   "text": "1678 views on Imgur",
   "image_url": "https://i.imgur.com/4zmGbMN.jpg?fb",
   "thumb_url": "https://i.imgur.com/4zmGbMN.jpg?fb",
   "og_scrape_url": "https://imgur.com/r/bears/4zmGbMN"
  }
 ],
 "latest_reactions": [],
 "own_reactions": [],
 "reaction_groups": {
  "love": {
    "count": 9,
    "sum_scores": 9,
    "first_reaction_at": "2024-09-05T13:17:05.138248Z",
    "last_reaction_at": "2024-09-05T13:17:11.454912Z"
  },
  "clap":
    "count": 9,
    "sum_scores": 13,
    "first_reaction_at": "2024-09-05T13:17:05.673605Z",
    "last_reaction_at": "2024-09-05T13:17:13.211086Z"
  },
  "wow": {
    "count": 9,
    "sum_scores": 9,
    "first_reaction_at": "2024-09-05T13:17:05.059252Z",
    "last_reaction_at": "2024-09-05T13:17:13.066055Z"
  },
  "haha": {
    "count": 9,
    "sum_scores": 9,
    "first_reaction_at": "2024-09-05T13:17:05.522053Z",
    "last_reaction_at": "2024-09-05T13:17:10.87445Z"
  },
  "like": {
    "count": 7,
    "sum_scores": 7,
    "first_reaction_at": "2024-09-05T13:17:04.977203Z",
    "last_reaction_at": "2024-09-05T13:17:14.856949Z"
  }
 },
 "reply_count": 0,
 "created_at": "2019-04-16T09:40:04.665274Z",
 "updated_at": "2019-04-16T09:40:04.665274Z",
 "message_text_updated_at":"2024-02-26T10:26:38.26136Z"
}
Messages returned by the API follow this structure
name	type	description	default	optional
id	string	The message ID. This is either created by Stream or set client side when the message is added. The message id has a maximum length of 255 characters, and can not contain , and %.		✓
html	string	The safe HTML generated from the raw text message. This field can only be set using server-side APIs or via the import		✓
type	string	The message type. See below for more information.		✓
user	object	The author user object. Schema is as described in the Setting the user portion of the docs.		✓
attachments	array	The list of attachments, either provided by the user or generated from a command or as a result of URL scraping. A message can have at most 30 attachments.		✓
latest_reactions	array	The latest reactions to the message created by any user. (Max 10 reactions)		✓
own_reactions	array	The array of reactions added to the message by the current user. e.g. [ReactionObject1, ReactionObject2] .		✓
reaction_counts	object	The reaction count by type for this message e.g. {“haha”: 3, “angry”: 2}. Please use reaction_groups instead, this field only exists for compatibility reasons.		✓
reply_count	integer	Reserved field indicating the number of replies for this message.		✓
parent_id	string	The ID of the parent message, if the message is a reply.		✓
created_at	date	Reserved field indicating when the message was created.		✓
updated_at	date	Reserved field indicating when the message was updated last time.		✓
deleted_at	date	Reserved field indicating when the message was deleted.		✓
deleted_for_me	boolean	Indicates if the message was deleted only for the current user.	-	✓
mentioned_users	array of users	The list of users that are mentioned in this message.		✓
message_text_updated_at	date	Field indicating when the message text was updated last time	-	✓
reaction_groups	object	The reaction groups by type. For example: {clap: {count: 5, sum_scores: 13, first_reaction_at: “2024-09-05T13:17:11.454912Z”, last_reaction_at: “2024-09-10T21:23:12.675478Z”}}	-	✓
Message Types
Chat supports different types of messages. The type of the message is set by the APIs or by chat bots and custom commands.

Name	Description
regular	A regular message created in the channel. This is the default type for messages posted on a channel.
ephemeral	A temporary message which is only delivered to one user. It is not stored in the channel history. Ephemeral messages are normally used by commands (e.g. /giphy ) to prompt messages or request for actions.
error	An error message generated as a result of a failed command. It is also ephemeral, as it is not stored in the channel history and is only delivered to one user.
reply	A message in a reply thread. Messages created with parent_id are automatically of this type.
system	A message generated by a system event, like updating the channel or muting a user.
deleted	A soft deleted message.
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Messages Overview
Next
File Uploads
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Message Format
Message Format
When you post a message on a Channel, there are a few things that happen on the server:

The text markdown format is parsed.
The first URL found in message.text is enriched, and additional information is added automatically. This gives you a preview of the images, videos, etc. from the open-graph data on the associated page.
Any slash commands such as /giphy, /ban, /flag, etc. are handled.

Attachment Format
Messages containing URLs will have a generated attachment with the following structure:

name	type	description	default	optional
type	string	The attachment type based on the URL resource. This can be: audio, image or video		✓
author_name	string	The name of the author.		✓
title	string	The attachment title.		✓
title_link	string	The link to which the attachment message points to.		✓
text	string	The attachment text. It will be displayed in the channel next to the original message.		✓
image_url	string	The URL to the attached image. This is present for URL pointing to an image article (eg. Unsplash)		✓
thumb_url	string	The URL to the attached file thumbnail. You can use this to represent the attached link.		✓
asset_url	string	The URL to the audio, video or image related to the URL.		✓
og_scrape_url	string	The original URL that was used to scrape this attachment.		✓
Open Graph Scraper
Our scraper uses the following user agent, as well as the latest desktop and mobile user agents: getstream.io/opengraph-bot facebookexternalhit/1.1 (+http://www.facebook.com/externalhit_uatext.php) If you plan to scrape any links to websites you can control, please ensure that this user agent isn’t blocked and returns valid opengraph data, for the best results.

Below is an example of URL enrichment as well as the resulting message structure:


Kotlin

JavaScript

Swift

PHP

Dart

Unreal

Python

Ruby

Go

C#

Java

Unity

const response = await channel.sendMessage({
  text: "Check this bear out https://imgur.com/r/bears/4zmGbMN",
});

None

{
 "id": "thierry-5e9619ec-1a0d-443b-ab26-c597ed7af3d0",
 "text": "Check this bear out https://imgur.com/r/bears/4zmGbMN",
 "html": "<p>Check this bear out <a href=\"https://imgur.com/r/bears/4zmGbMN\" rel=\"nofollow\">https://imgur.com/r/bears/4zmGbMN</a></p>\n",
 "type": "regular",
 "user": {
  "id": "thierry",
  "role": "user",
  "created_at": "2019-04-03T14:42:47.087869Z",
  "updated_at": "2019-04-16T09:20:03.982283Z",
  "last_active": "2019-04-16T11:23:51.168113408+02:00",
  "online": true
 },
 "attachments": [
  {
   "type": "image",
   "author_name": "Imgur",
   "title": "An update: Dushi made it safe to Bear Sanctuary Müritz",
   "title_link": "https://imgur.com/4zmGbMN",
   "text": "1678 views on Imgur",
   "image_url": "https://i.imgur.com/4zmGbMN.jpg?fb",
   "thumb_url": "https://i.imgur.com/4zmGbMN.jpg?fb",
   "og_scrape_url": "https://imgur.com/r/bears/4zmGbMN"
  }
 ],
 "latest_reactions": [],
 "own_reactions": [],
 "reaction_groups": {
  "love": {
    "count": 9,
    "sum_scores": 9,
    "first_reaction_at": "2024-09-05T13:17:05.138248Z",
    "last_reaction_at": "2024-09-05T13:17:11.454912Z"
  },
  "clap":
    "count": 9,
    "sum_scores": 13,
    "first_reaction_at": "2024-09-05T13:17:05.673605Z",
    "last_reaction_at": "2024-09-05T13:17:13.211086Z"
  },
  "wow": {
    "count": 9,
    "sum_scores": 9,
    "first_reaction_at": "2024-09-05T13:17:05.059252Z",
    "last_reaction_at": "2024-09-05T13:17:13.066055Z"
  },
  "haha": {
    "count": 9,
    "sum_scores": 9,
    "first_reaction_at": "2024-09-05T13:17:05.522053Z",
    "last_reaction_at": "2024-09-05T13:17:10.87445Z"
  },
  "like": {
    "count": 7,
    "sum_scores": 7,
    "first_reaction_at": "2024-09-05T13:17:04.977203Z",
    "last_reaction_at": "2024-09-05T13:17:14.856949Z"
  }
 },
 "reply_count": 0,
 "created_at": "2019-04-16T09:40:04.665274Z",
 "updated_at": "2019-04-16T09:40:04.665274Z",
 "message_text_updated_at":"2024-02-26T10:26:38.26136Z"
}
Messages returned by the API follow this structure
name	type	description	default	optional
id	string	The message ID. This is either created by Stream or set client side when the message is added. The message id has a maximum length of 255 characters, and can not contain , and %.		✓
html	string	The safe HTML generated from the raw text message. This field can only be set using server-side APIs or via the import		✓
type	string	The message type. See below for more information.		✓
user	object	The author user object. Schema is as described in the Setting the user portion of the docs.		✓
attachments	array	The list of attachments, either provided by the user or generated from a command or as a result of URL scraping. A message can have at most 30 attachments.		✓
latest_reactions	array	The latest reactions to the message created by any user. (Max 10 reactions)		✓
own_reactions	array	The array of reactions added to the message by the current user. e.g. [ReactionObject1, ReactionObject2] .		✓
reaction_counts	object	The reaction count by type for this message e.g. {“haha”: 3, “angry”: 2}. Please use reaction_groups instead, this field only exists for compatibility reasons.		✓
reply_count	integer	Reserved field indicating the number of replies for this message.		✓
parent_id	string	The ID of the parent message, if the message is a reply.		✓
created_at	date	Reserved field indicating when the message was created.		✓
updated_at	date	Reserved field indicating when the message was updated last time.		✓
deleted_at	date	Reserved field indicating when the message was deleted.		✓
deleted_for_me	boolean	Indicates if the message was deleted only for the current user.	-	✓
mentioned_users	array of users	The list of users that are mentioned in this message.		✓
message_text_updated_at	date	Field indicating when the message text was updated last time	-	✓
reaction_groups	object	The reaction groups by type. For example: {clap: {count: 5, sum_scores: 13, first_reaction_at: “2024-09-05T13:17:11.454912Z”, last_reaction_at: “2024-09-10T21:23:12.675478Z”}}	-	✓
Message Types
Chat supports different types of messages. The type of the message is set by the APIs or by chat bots and custom commands.

Name	Description
regular	A regular message created in the channel. This is the default type for messages posted on a channel.
ephemeral	A temporary message which is only delivered to one user. It is not stored in the channel history. Ephemeral messages are normally used by commands (e.g. /giphy ) to prompt messages or request for actions.
error	An error message generated as a result of a failed command. It is also ephemeral, as it is not stored in the channel history and is only delivered to one user.
reply	A message in a reply thread. Messages created with parent_id are automatically of this type.
system	A message generated by a system event, like updating the channel or muting a user.
deleted	A soft deleted message.
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Messages Overview
Next
File Uploads
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
File Uploads
File Uploads
Stream Chat provides methods to upload files like images, videos and more to the Stream CDN or to your own CDN. This allows you to use them, for example, as attachments in messages, user avatars or channel avatars.

Uploading files
When uploading a file, it can belong to a channel so that it can be used as an attachment in a message, or it can be a standalone file to be used anywhere in your application, like a user profile image or channel avatar.

Attachments
For uploading files as message attachments in a channel, you can either send the attachment directly as part of the message and let the SDK handle the upload progress, or you can upload the file to the channel first, and then attach it to the message.


Kotlin

JavaScript

Swift

PHP

Dart

Node

Unreal

Python

Ruby

C#

Unity

Java

// Capture a file using the HTML5 input element
// or a similar feature in your preferred web framework.
//
// Example: <input type="file" onChange={getUrl}></input>
async function getUrl(event) {
  const files = event.target.files;
  const response = await channel.sendImage(files[0]);
}
Standalone
In some cases, you may need to upload files that are not tied to a specific channel or message. For example, uploading a user profile image or channel avatar. These uploads are independent and can be used anywhere in your application.


Swift

Dart

import StreamChat
// Upload an image to the CDN.
let chatClient = ChatClient.shared
let imageLocalFileUrl = try image.tempLocalFileUrl()
chatClient.uploadAttachment(
    localUrl: imageLocalFileUrl,
    progress: { progressValue in
        // Track upload progress (0.0 to 1.0)
    },
    completion: { result in
        switch result {
        case .success(let uploadedFile):
            let remoteUrl = uploadedFile.url
            // Example: Update user avatar
            chatClient.currentUserController().updateUserData(
                imageURL: remoteUrl
            )
        case .failure(let error):
            // Handle upload error
        }
    }
)
/// Example on how to save an image to a temporary file URL.
extension UIImage {
    func tempLocalFileUrl() throws -> URL? {
        guard let imageData = jpegData(compressionQuality: 1.0) else { return nil }
        let imageName = "\(UUID().uuidString).jpg"
        let localPath = NSTemporaryDirectory().appending(imageName)
        let photoURL = URL(fileURLWithPath: localPath)
        try imageData.write(to: photoURL)
        return photoURL
    }
}
Deleting files
If you want to save storage space you can delete the uploaded files.


Kotlin

Node

Unreal

Java

PHP

Python

Ruby

Go

C#

Unity

Swift

Dart

val channelClient = client.channel("messaging", "general")
// Deletes the image
channelClient.deleteImage("{{ url of uploaded image }}").enqueue()
// Deletes the file
channelClient.deleteFile("{{ url of uploaded file }}").enqueue()
File Requirements
Stream has specific requirements for the files that can be uploaded to the CDN.

Images
Stream supported image types are: image/bmp, image/gif, image/jpeg, image/png, image/webp, image/heic, image/heic-sequence, image/heif, image/heif-sequence, image/svg+xml.

You can set a more restrictive list for your application if needed.

The maximum file size is 100MB.

Other Files
Stream will not block any file types from uploading, however, different clients may handle different types differently or not at all.

You can set a more restrictive list for your application if needed.

The maximum file size is 100MB.

Allow / Block file extensions
Stream will allow any file extension. If you want to be more restrictive for an application, this is can be set via API or by logging into your dashboard.

To update via the dashboard, login and go to the Chat Overview page >> Upload Configuration

API updates are made using UpdateAppSettings, see the App Settings page

Access control and link expiration
The Stream CDN URL returned during the upload contains a signature that validates the access to the file it points to. Only the members of a channel a file was uploaded to can see the attachment and its unique, signed link. Links can only be accessed with a valid signature, which also protects against enumeration attacks.

Whenever messages containing your attachments are retrieved (i.e., when querying a channel), the attachment links will contain a new, fresh signature.

A single Stream CDN URL expires after 14 days, after which its signature will stop working and the link won’t be valid anymore. You can check when a link will expire by comparing the current time with the Unix timestamp in the Expires parameter of the link’s query: https://us-east.stream-io-cdn.com/0000/images/foo.png?…&Expires=1602666347&…

As explained above, all operations that return messages will refresh links automatically, but if you are storing a message containing an expired link you can perform a getMessage call to retrieve fresh links for its attachments.

Image resizing
You can automatically resize an image appending query parameters to a valid image link stored on the Stream CDN.

An image can only be resized if the total pixel count of the source image is 16.800.000 or less. Attempting to resize an image with more pixels will result in an API error. An image of 4000 by 4000 would be accepted, but an image of 4100 by 4100 would pass the upper treshold for resizing.

There are four supported params - all of them are optional and can be used interchangeably:

Parameter	Type	Values	Description
w	number		Width
h	number		Height
resize	string	clip, crop, scale, fill	The resizing mode
crop	string	center, top, bottom, left, right	The cropping direction during resize
Resized images will count against your stored files quota.

Using your own CDN
All SDKs make it easy to use your own CDN for file uploads. The code examples below show how to use a custom CDN client.


Kotlin

JavaScript

Dart

Swift

Unreal

Java

Unity

messageComposer.attachmentManager.setCustomUploadFn(async (file) => {
  // Upload to custom CDN
  const result = await customCDN.upload(file);
  return { file: result.url };
});
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Message Format
Next
Reactions
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Reactions
Reactions
Stream Chat has built-in support for user Reactions. Common examples are likes, comments, loves, etc. Reactions can be customized so that you are able to use any type of reaction your application requires.


Similar to other objects in Stream Chat, reactions allow you to add custom data to the reaction of your choice. This is helpful if you want to customize the reaction logic.

name	type	description	default	optional
message_id	string	ID of the message to react to		
reaction	object	Reaction object		
reaction.type	string	Type of the reaction. User could have only 1 reaction of each type per message		
reaction.score	integer	Score of the reaction for cumulative reactions (see example below)	1	✓
user_id	string	User ID for server side calls		✓
enforce_unique	boolean	If set to true, new reaction will replace all reactions the user has (if any) on this message	false	✓
skip_push	boolean	Do not send a push notification	false	✓
emoji_code	string	Accepts an unicode which is used by the backend to display the emoji in push notification		✓
Custom data for reactions is limited to 1KB.


Kotlin

JavaScript

Swift

PHP

Dart

Python

Go

Unreal

Ruby

C#

Unity

// Add reaction 'love' with custom field, using emoji
const reaction = await channel.sendReaction(messageID, {
  type: "love",
  myCustomField: "💙",
});
// Add reaction 'love' from the server side
const reaction = await channel.sendReaction(messageID, {
  type: "love",
  user_id: userid,
});
// Add reaction 'like' and replace all other reactions of this user by it
const reaction = await channel.sendReaction(
  messageID,
  { type: "love", user_id: userid },
  { enforce_unique: true },
);
Removing a Reaction

Kotlin

JavaScript

Swift

PHP

Dart

Python

Go

Unreal

Ruby

C#

Unity

Java

await channel.deleteReaction(messageID, "love");
Retrieve Reactions
Reactions are being returned as a part of the Message object. Please refer to the Message format section for more details.

Paginating Reactions
Messages returned by the APIs automatically include the 10 most recent reactions. You can also retrieve more reactions and paginate using the following logic, consider that the maximum value for the Limit parameter is 300 and for the Offset parameter is 1000:


Kotlin

JavaScript

Swift

PHP

Dart

Python

Go

Unreal

Ruby

C#

Unity

Java

// get the first 10 reactions
const response = await channel.getReactions(messageID, { limit: 10 });
// get 3 reactions past the first 10
const response = await channel.getReactions(messageID, { limit: 3, offset: 10 });// Load 10 first reactions
messageController.loadReactions(limit: 10, offset: 0) { result in
  // …
  let loadedReactions = messageController.reactions
}
// Load 10 more reactions
messageController.loadNextReactions(limit: 10) { error in
  // …
  let loadedReactions = messageController.reactions
}
Cumulative (Clap) Reactions
You can use the Reactions API to build something similar to Medium’s clap reactions. If you are not familiar with this, Medium allows you to clap articles more than once and shows the sum of all claps from all users.


To do this, you only need to include a score for the reaction (ie. user X clapped 25 times) and the API will return the sum of all reaction scores as well as each user’s individual scores (ie. clapped 475 times, user Y clapped 14 times).


Kotlin

JavaScript

Dart

Python

PHP

Go

Swift

Unreal

Ruby

C#

Unity

Java

// user claps 5 times on a message
await channel.sendReaction(messageID, {
  type: "clap",
  score: 5,
});
// same user claps 20 times more
await channel.sendReaction(messageID, {
  type: "clap",
  score: 25,
});
Query Reactions
This endpoint allow you to query reactions by filtering over type and user on a specific message id.

In case of this endpoint is used client side, the user need to have permission to read channel.


JavaScript

const id = uuidv4();
await client.queryReactions(message.id, { type: "like" });
await client.queryReactions(message.id, { user_id: id });
Clearly it is possible to have different call for pagination:

first call will fetch 25 reactions

the second returns other 5 reactions starting from the latest of the first call


JavaScript

const data = await client.queryReactions(message.id, {});
const dataPage2 = await reactionClient.queryReactions(
  message.id,
  {},
  {},
  { limit: 5, next: data.next },
);
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
File Uploads
Next
Threads & Replies
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Threads & Replies
Threads & Replies
Threads and replies provide your users with a way to go into more detail about a specific topic.


This can be very helpful to keep the conversation organized and reduce noise. To create a thread you simply send a message with a parent_id. Have a look at the example below:


Kotlin

JavaScript

Swift

PHP

Dart

Unreal

Python

Ruby

Go

C#

Unity

Java

const reply = await channel.sendMessage({
  text: "Hey, I am replying to a message!",
  parent_id: parentID,
  show_in_channel: false,
});
If you specify show_in_channel, the message will be visible both in a thread of replies as well as the main channel.

Messages inside a thread can also have reactions, attachments and mention as any other message.

Thread Pagination
When you read a channel you do not receive messages inside threads. The parent message includes the count of replies which it is usually what apps show as the link to the thread screen. Reading a thread and paginating its messages works in a very similar way as paginating a channel.


Kotlin

JavaScript

Swift

Dart

Unreal

Python

Ruby

Go

C#

Unity

Java

// retrieve the latest 20 messages inside the thread
await channel.getReplies(parentMessageId, { limit: 20 });
// retrieve the 20 more messages before the message with id "42"
await channel.getReplies(parentMessageId, { limit: 20, id_lte: "42" });
// retrive the oldest 20 messages in the thread
await channel.getReplies(parentMessageId, { limit: 20 }, [{ created_at: 1 }]); // default sort is created_at: -1
Quote Message
Instead of replying in a thread, it’s also possible to quote a message. Quoting a message doesn’t result in the creation of a thread; the message is quoted inline.

To quote a message, simply provide the quoted_message_id field when sending a message:


Kotlin

JavaScript

Dart

Swift

Unreal

Python

Ruby

C#

Go

Unity

Java

// Create the initial message
await channel.sendMessage({
  id: "first_message_id",
  text: "The initial message",
});
// Quote the initial message
const res = await channel.sendMessage({
  id: "message_with_quoted_message",
  text: "This is the first message that quotes another message",
  quoted_message_id: "first_message_id",
});
Based on the provided quoted_message_id, the quoted_message field is automatically enriched when querying channels with messages. Example response:


JavaScript

Unity

{
  "id": "message_with_quoted_message",
  "text": "This is the first message that quotes another message",
  "quoted_message_id": "first_message_id",
  "quoted_message": {
    "id": "first_message_id",
    "text": "The initial message"
  }
}
Quoted messages are only available one level deep. If you want to access deeply quoted messages you will have to fetch them directly either finding the message in response of channel.query() or querying message by its ID. Example: Message A quotes Message B and Message B quotes Message C. In this case it’s not possible to access Message C through Message A directly. You have to fetch Message B from API in order to access it

Thread List
Query Threads
It is possible to query the list of threads that current user is participant of. This is useful to create thread list similar to what Slack or Discord has. Response will include threads with unread replies first, sorted by the latest reply timestamp in descending order. Threads with no unread replies will follow, also sorted by the latest reply timestamp in descending order.


Kotlin

JavaScript

Swift

const threads = await client.queryThreads();
for (const thread of threads) {
  const state = thread.state.getLatestValue();
  console.log(state.participants);
  console.log(state.replies);
  console.log(state.parentMessage.text);
  console.log(state.read); // read states of the participants
}
Response
You can also paginate over the thread list or request specific number of latest replies per thread.


Kotlin

JavaScript

Swift

// Example: Get threads created by a specific user, updated after a certain date,
// sorted by creation date (newest first)
const { threads: page1, next: next1 } = await client.queryThreads({
  sort: [{ created_at: -1 }],
  filter: {
    created_by_user_id: { $eq: "user1" },
    updated_at: { $gte: "2024-01-01T00:00:00Z" },
  },
  limit: 10, // Get 10 threads per page
});
// request the next page
const { threads: page2, next: next2 } = await client.queryThreads({
  sort: [{ created_at: -1 }],
  filter: {
    created_by_user_id: { $eq: "user1" },
    updated_at: { $gte: "2024-01-01T00:00:00Z" },
  },
  limit: 10,
  next: next1,
});
Following is the list of supported options for querying threads:

name	type	description	default	optional
reply_limit	number	Number of latest replies to fetch per thread	2	✓
participant_limit	number	Number of thread participants to request per thread	100	✓
limit	number	Maximum number of threads to return in response	10	✓
watch	boolean	If true, all the channels corresponding to threads returned in response will be watched	true	✓
member_limit	number	Number of members to request per thread channel	100	✓
Filtering and Sorting Threads
You can filter and sort threads using MongoDB-style query operators. This allows you to create more specific queries and organize the results according to your needs.

Supported Sort Fields
You can sort threads by the following fields:

active_participant_count: Number of active participants in the thread
created_at: Thread creation timestamp
last_message_at: Timestamp of the last message in the thread
parent_message_id: ID of the parent message
participant_count: Total number of participants in the thread
reply_count: Number of replies in the thread
updated_at: Thread last update timestamp
Use 1 for ascending order and -1 for descending order.

Allowed Sort Combinations
When sorting threads, below are the supported field combinations:

has_unread, last_message_at, parent_message_id
last_message_at, parent_message_id
created_at
updated_at
reply_count
participant_count
active_participant_count
parent_message_id
Default Sort
If no sort parameters are provided, threads are sorted by default using the following combination:


[{ "has_unread": -1 }, { "last_message_at": -1 }, { "parent_message_id": -1 }]
This means threads are sorted by:

Unread status (unread threads first)
Last message timestamp (newest first)
Parent message ID (descending)
Supported Filter Fields
You can filter threads using the following fields and operators:

Name	Type	Supported Operators	Description
channel_cid	string or list of strings	$eq, $in	Filter by channel CID
channel.disabled	boolean	$eq	Filter by channel disabled field
channel.team	string or list of strings	$eq, $in	Filter by channel team field
parent_message_id	string or list of strings	$eq, $in	Filter by parent message ID
created_by_user_id	string or list of strings	$eq, $in	Filter by thread creator’s user ID
created_at	string (RFC3339 timestamp)	$eq, $gt, $lt, $gte, $lte	Filter by thread creation timestamp
updated_at	string (RFC3339 timestamp)	$eq, $gt, $lt, $gte, $lte	Filter by thread update timestamp
last_message_at	string (RFC3339 timestamp)	$eq, $gt, $lt, $gte, $lte	Filter by last message timestamp

JavaScript

Python

Java

Go

PHP

C#

Ruby

// Example: Get threads created by a specific user, updated after a certain date,
// sorted by creation date (newest first)
const { threads: page1, next: next1 } = await client.queryThreads({
  sort: [{ created_at: -1 }],
  filter: {
    created_by_user_id: { $eq: "user1" },
    updated_at: { $gte: "2024-01-01T00:00:00Z" },
  },
  limit: 10, // Get 10 threads per page
});
// request the next page
const { threads: page2, next: next2 } = await client.queryThreads({
  sort: [{ created_at: -1 }],
  filter: {
    created_by_user_id: { $eq: "user1" },
    updated_at: { $gte: "2024-01-01T00:00:00Z" },
  },
  limit: 10,
  next: next1,
});
Thread List Management
ThreadManager class offers built-in pagination handling for threads with own state store to access loaded threads. To access threads you can either subscribe to the ThreadManager state or access the latest value by calling getLatestValue on state property of the ThreadManager .


JavaScript

const threadManager = new ThreadManager({ client });
const unsubscribe = threadManager.state.subscribe((nextState) => {
  console.log(nextState.threads);
});
threadManager.loadNextPage();
// or
await threadManager.loadNextPage();
const { threads } = threadManager.state.getLatestValue();
Client instance already comes with one ThreadManager instance which can be accessed via threads property of the client ( client.threads ).

Event Handling Of Threads
Each thread instance comes with registerSubscriptions method which registers handlers to appropriate thread-related events. With subscriptions registered, the updates to the state are done automatically and can be accessed by subscribing to the state updates.


JavaScript

const { threads } = await client.queryThreads({ watch: true, limit: 1 });
const [thread] = threads;
thread.registerSubcsriptions();
const unsubscribe = thread.state.subscribe((nextState) => {
  console.log(nextState.replies);
});
Note that watch parameter is required when querying for threads in this case as without it, the channel to which the thread is linked won’t receive updates.

If you’re using ThreadManger to manage your list of threads, you can call registerSubscriptions method on the manager instance and the manager will automatically handle subscriptions (registration and cleanup) of the added and removed threads.


JavaScript

const threadManager = new ThreadManager({ client });
threadManager.registerSubscriptions();
await threadManager.loadNextPage();
// these threads are listening to linked channel events
const { threads } = threadManager.state.getLatestValue();
Get Thread By ID
This endpoint returns a thread by the given threadId.


Kotlin

JavaScript

const threadId = "<parent_message_id>";
const thread = await client.getThread(threadId, {
  watch: true, // optional
  reply_limit: 3, // optional
  member_limit: 0, // optional
  participant_limit: 10, // optional
});
Update Thread Title and Custom Data
You can assign a title and any additional custom data to each thread.


Kotlin

JavaScript

Swift

const threadId = "<parent_message_id>";
// optional
const thread = await client.getThread(threadId);
thread.registerSubcsriptions();
const { thread: updatedThread } = await client.partialUpdateThread(threadId, {
  set: {
    title: "New Title",
    extraData: "Hello World",
  },
});
console.log(updatedThread.title);
console.log(updatedThread.extraData);
// or if you're using optional approach (Thread instance)
const { title, custom } = thread.state.getLatestValue();
console.log(title, custom.extraData);
To get full type support for your custom data, you can extend ThreadResponseCustomData interface through module augmentation. Simply create a declaration file within your project and add your custom properties to our interface:


TypeScript

// yourDeclarationFile.d.ts
import "stream-chat";
declare module "stream-chat" {
  interface ThreadResponseCustomData {
    extraData?: string;
  }
}
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Reactions
Next
Unread Reminders
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Unread Reminders
Unread Reminders
Unread Reminders allow you to notify users about messages they did not read. They can be used to trigger an email, push notification or SMS to the user.

When enabled, Stream Chat will send an event to your web-hook or SQS queue every time a user has an unread message in a channel with 10 members or less for longer than five minutes.

By default, an unread reminder will be sent if the user did not read the message within 5 minutes. This interval can be changed for your application. Any interval in seconds between 60 and 86,400 seconds (24 hours) is allowed. If there are more messages sent after a reminder was sent, we will send another reminder for the new messages.

Unread reminders are configurable as channel type features, by default this feature is disabled. Make sure to enable it for your channel types. This can be done using the API or from the Dashboard.


JavaScript

Python

Ruby

C#

Go

Java

PHP

Unity

// enable reminders for the channel type `messaging`
await client.updateChannelType("messaging", {
  reminders: true,
});
// change reminders interval to 1 hour
await client.updateAppSettings({ reminders_interval: 3600 });
Reminders are sent only if all conditions are met:

The channel has 10 members or less

The channel type has the reminders feature enabled

The channel has at least one unread message

The channel has the read_events feature enabled

The unread message(s) type is regular or system

The unread message is not deleted

The channel is not deleted

The default channel member limit is 10. To increase this limit, please upgrade to an Enterprise plan and contact support

Reminder Event
Reminder events contain all the information needed to send a notification to the user without additional API calls. This makes it easy to pipe email/push/sms services.

Field	Value
type	The type of the event, reminders have type user.unread_message_reminder
user	The target user for this the reminder. This is the user that did not mark the channel as read
channels	The object containing all channels with at least one unread message for this user
created_at	The time the event was sent
The channels object contains up to 10 objects and have this structure

Field	Value
channel	The channel object, this includes the list of members.
messages	The last five messages in the channel (in descending order)
Response
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Threads & Replies
Next
Silent & System Messages
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Silent & System Messages
Silent & System Messages
Sometimes you want to add system or transactional messages to channels such as: “your ride is waiting for you”, “James updated the information for the trip”, “You and Jane are now matched” and so on.

You may not want these messages to mark a channel as unread or increase the unread messages for users.

Silent messages are special messages that don’t increase the unread messages count nor mark a channel as unread. Creating a silent message is very simple, you only need to include the silent field boolean field and set it to true .


Kotlin

JavaScript

Swift

Dart

Unreal

PHP

Python

Ruby

Go

C#

Unity

Java

const text = "You completed your trip";
const message = {
  text,
  user: systemUser,
  silent: true,
  attachments: [{ type: "trip", ...tripData }],
};
await channel.sendMessage(message);
Existing messages cannot be turned into a silent message or vice versa.

Silent replies will still increment a message’s reply_count

Silent messages do send push notifications by default. To skip our push notification service, mark the message with skip_push: true, as described here.

It is also possible to send system messages. System messages differ from normal messages in the way they are presented to the user. Like the name says, system messages are normally send from the system itself, but a user is able to send it as well by specifying type: 'system' with the message. The user who sends a system message client-side should have the Create System Message permission. Server-side system messages don’t need that permission.


JavaScript

PHP

Python

Ruby

Go

Java

const text = "You completed your trip";
const message = {
  text,
  user: systemUser,
  type: "system",
};
await channel.sendMessage(message);
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Unread Reminders
Next
Search
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Search
Search
Stream recently upgraded its search capabilities to provide more options for sorting and pagination. Applications created after November 3rd, 2021 will automatically be using the latest version. Accounts created before November 3rd, 2021 need to contact support to have the latest version enabled.

Message search is built-in to the chat API. You can enable and/or disable the search indexing on a per channel type through the Stream Dashboard.

The command shown below selects the channels in which John is a member. Next, it searches the messages in those channels for the keyword “‘supercalifragilisticexpialidocious’”.

Query Parameters
name	type	description	default	optional
filter_conditions	object	Filter conditions for channels. We will only ever search a maximum of 500 channels at a time, so it is beneficial to make these filters as strict as possible. See the Query Channels section for information about these filters.	-	
message_filter_conditions	object	Filter conditions for messages. See the next section for details. You must either specify query or message_filter_conditions.	-	✓
query	string	A string to search for (which is a full text search). This is equivalent passing {text: {$q: }} to message_filter_conditions. You must either specify query or message_filter_conditions.	-	✓
limit	integer	The number of messages to return.	100	✓
offset	integer	The pagination offset. See the Pagination section for more information. You cannot use a non-zero offset with the sort or the next parameters.	0	✓
sort	object or array of objects	The sorting used for the messages matching the filters. Sorting is based on field and direction, and multiple sorting options can be provided. Direction can be ascending (1) or descending (-1).	[{relevance: -1}, {id: 1}]	✓
next	string	A key used to paginate. See the Pagination section for more information.	-	✓
Message Filter Conditions
You can use following operators and fields in order to search messages:

Field	Description	Allowed operators
id	message ID	$eq, $gt, $gte, $lt, $lte, $in
text	text of the message	$q. $autocomplete, $eq, $gt, $gte, $lt, $lte, $in
type	type of the message. Messages with type ‘system’ and ‘deleted’ are excluded from results.	$eq, $gt, $gte, $lt, $lte, $in
parent_id	the parent message ID (if the message is a reply)	$eq, $gt, $gte, $lt, $lte, $in
reply_count	number of replies the message has	$eq, $gt, $gte, $lt, $lte, $in
attachments	whether or not the message contains an attachment	$exists, $eq, $gt, $gte, $lt, $lte, $in
attachments.type	the type of the attachment	$eq, $in
mentioned_users.id	user ID that is included in the message’s mentions	$contains
user.id	user ID of the user that sent the message	$eq, $gt, $gte, $lt, $lte, $in
created_at	created at time	$eq, $gt, $gte, $lt, $lte, $in
updated_at	updated at time	$eq, $gt, $gte, $lt, $lte, $in
pinned	whether the message has been pinned	$eq
any custom field that is attached to your message	$eq, $gt, $gte, $lt, $lte, $in
Stream Chat does not run MongoDB on the backend, only a subset of the query options are available.

Sorting
Messages default to being sorted by relevance to your query, with the message ID as a tie-breaker for any equally relevant results. If your query does not use the $q or $autocomplete operators then all results are considered equally relevant.

You can sort by any of the filter-able fields, including custom fields. Custom fields that are numbers will be sorted numerically, while custom string fields will be sorted lexicographically. See the Pagination section for examples of sorting.

Pagination
There are two ways to paginate through search results:

Version 1 - Using limit and offset

Version 2 - Using limit and next/previous values

Limit and offset will allow you to access up to 1000 results matching your query. You will not be able to sort using limit and offset. The results will instead be sorted by relevance and message ID. See the code at the top of the page for examples of limit and offset pagination.

Next pagination will allow you to access all search results that match your query, and you will be able to sort using any filter-able fields and custom fields.

Pages of sort results will be returned with next and previous strings, which tell the API where to start searching from and what sort order to use. You can supply those values as a next parameter when making a query to get a new page of results.


Kotlin

JavaScript

Ruby

Python

Java

PHP

Go

C#

Unity

Swift

const channelFilters = { cid: "messaging:my-channel" };
const messageFilters = { text: { $autocomplete: "supercali" } };
// first 10 results
// sorted by relevance in descending order, then updated_at in ascending order,
// and then my_custom_field in descending order
const page1 = await client.search(channelFilters, messageFilters, {
  sort: [{ relevance: -1 }, { updated_at: 1 }, { my_custom_field: -1 }],
  limit: 10,
});
// next 10 results
// this query will use the same sort order as in your first query,
// as the sort order is embedded in the next value
const page2 = await client.search(channelFilters, messageFilters, {
  limit: 10,
  next: page1.next,
});
// the previous 10 results
const page1Again = await client.search(channelFilters, messageFilters, {
  limit: 10,
  next: page2.previous,
});
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Silent & System Messages
Next
Pinned messages
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Pinned messages
Pinned messages
Pinned messages allow users to highlight important messages, make announcements, or temporarily promote content. Pinning a message is, by default, restricted to certain user roles, but this is flexible. Each channel can have multiple pinned messages and these can be created or updated with or without an expiration.

Pin and unpin a message
An existing message can be updated to be pinned or unpinned by using the .pinMessage and .unpinMessage methods. Or a new message can be pinned when it is sent by setting the pinned and pin_expires fields when using channel.sendMessage .


Kotlin

JavaScript

Dart

Swift

Unreal

PHP

Python

Ruby

Go

C#

Unity

Java

// create pinned message
const { message } = await channel.sendMessage({
  text: "my message",
  pinned: true,
  pin_expires: "2077-01-01T00:00:00Z",
});
// unpin message
await client.unpinMessage(message);
// pin message for 120 seconds
await client.pinMessage(message, 120);
// change message expiration to 2077
await client.pinMessage(message, "2077-01-01T00:00:00Z");
// remove expiration date from pinned message
await client.pinMessage(message, null);
name	type	description	default	optional
pinned	boolean	Indicates whether the message is pinned or not	false	✓
pinned_at	string	Date when the message got pinned	-	✓
pin_expires	string	Date when the message pin expires. An empty value means that message does not expire	null	✓
pinned_by	User	The user that pinned the message	-	✓
To pin the message user has to have PinMessage permission. You can find the list of permissions and defaults in Permission Resources and Default Permissions sections

Retrieve pinned messages
You can easily retrieve the last 10 pinned messages from the channel.pinned_messages field:


Kotlin

JavaScript

Dart

Swift

Unreal

PHP

Python

Ruby

Go

C#

Unity

Java

// get channel state
const channelState = await client.channel("messaging", channelId).query();
// get pinned messages from it
const pinnedMessages = channelState.pinned_messages;
To learn more about channels you can visit Querying Channels page

Paginate over all pinned messages
Stream Chat also provides dedicated endpoint for pinned messages of the channel which can be used to retrieve all pinned messages page by page:


Kotlin

JavaScript

Unreal

PHP

Python

Ruby

Go

C#

Unity

Java

Swift

// list first page of pinned messages of the channel with descending direction (newest on top)
const descPage1 = await channel.getPinnedMessages(
  { limit: 10 },
  { pinned_at: -1 },
);
const descLastMsg = descPage1.messages[descPage1.messages.length - 1];
// list next page of pinned messages
const descPage2 = await channel.getPinnedMessages(
  {
    limit: 10,
    id_lt: descLastMsg.id,
  },
  { pinned_at: -1 },
);
// list first page of pinned messages of the channel with ascending direction (oldest on top)
const ascPage1 = await channel.getPinnedMessages({ limit: 10 });
const ascLastMsg = ascPage1.messages[ascPage1.messages.length - 1];
// list next page of pinned messages with ascending direction
const ascPage2 = await channel.getPinnedMessages({
  limit: 10,
  id_gt: ascLastMsg.id,
});
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Search
Next
Restricted Message Delivery
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Restricted Message Delivery
Restricted Message Delivery
Restricted message delivery is a feature that allows sending a message in channel to one or more specific users, thereby limiting visibility to other users in that channel. If you want to inform 1 specific user in a channel with a system message for example, then restricted message delivery is perfectly feature for it.

This feature is only available on Stream’s Enterprise pricing plans. Request the Stream team to enable this feature for your app by contacting support.

Possible use cases
Taxi app (like Uber) use case
In a taxi app where both the driver and the passenger share a channel, you could provide either of them with additional updates.

Alert the driver that the passenger is close by.
Alert the passenger of where the driver is.
Moderation use case
The system may wish to send a message to only a single user to alert them that there may be fraudulent activity from the another user in the channel.
Show a blocked user a message to let them know they have been suspended.
Marketplace use case
Show alternative listings to a potential buyer, thereby improving customer engagement.
Show a message the product is reserved for the user.
Sending a message with restricted visibility
In order to send a message with restricted visibility the user needs to have the CreateRestrictedVisibilityMessage permission. A message with restricted visibility is send by adding a list of users to the restricted_visibility property. Please note that updating the list of users who can see the message is not possible after the message has been send.


JavaScript

Go

Python

Php

Java

Ruby

C#

// Get a channel
const channel = client.Channel("messaging", "ride-08467339");
// Send a message only visible to Jane
const message = await channel.sendMessage({
  text: "Hi Jane, your driver John will be at your location in 1 minute",
  type: "system",
  restricted_visibility: ["Jane"],
});
Additional information
Visibility to other users
By default a restricted visibility message is only visible to the sender of the message and the users in the restricted_visibility list. If you want other users to be able to view those messages as well, you can give those users the ReadRestrictedVisibilityMessage permission. By default this permission is only granted to admin roles.

Pinning a restricted visibility message
Pinning a restricted visibility message to a channel is not allowed, simply because pinning a message is meant to bring attention to that message, that is not possible with a message that is only visible to a subset of users.

Unread counts
If a restricted visibility message is send to a channel and the user cannot see that message then the unread count will not be increased for that user. The unread count will be increased for users who can see the message.

Truncating and updating channels
When truncating or updating a channel, the user can choose to send a system message in the same request. However, this message cannot contain a list of restricted visibility users. The reason being is both operations send an event to all channel members. This event includes the optional message. All channel members need to be notified about the channel update or truncation, it is not possible to send a message with restricted visbility. If you want to send a message with restricted visibility, then the update or truncate the channel first, after that you can send a message with restricted visibility to the channel.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Pinned messages
Next
Translation
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Translation
Translation
Chat messages can be translated on-demand or automatically, this allows users speaking different languages on the same channel.

Message Translation Endpoint
This API endpoint translates an existing message to another language. The source language is inferred from the user language or detected automatically by analyzing its text. If possible it is recommended to store the user language, see ” Set user language ” section later in this page.


Kotlin

Swift

Dart

JavaScript

Unreal

PHP

Python

Ruby

Go

C#

Unity

Java

await channel.sendMessage({
  id: messageID,
  text: "Hello, I would like to have more information about your product.",
});
// returns the message.text translated into French
const response = await client.translateMessage(messageID, "fr");
// the translation will be added to the i18n object
console.log(response.message.i18n.fr_text);
// "Bonjour, J'aimerais avoir plus d'informations sur votre produit.",
The endpoint returns the translated message, updates it and sends a message.updated event to all users on the channel.

Only the text field is translated, custom fields and attachments are not included.

i18n data
When a message is translated, the i18n object is added. The i18n includes the message text in all languages and the code of the original language.

The i18n object has one field for each language named using this convention language-code_text

Here is an example after translating a message from english into French and Italian.


JSON

{
  "fr_text": "Bonjour, J'aimerais avoir plus d'informations sur votre produit.",
  "it_text": "Ciao, vorrei avere maggiori informazioni sul tuo prodotto.",
  "language": "en"
}
Automatic translation
Automatic translation translates all messages immediately when they are added to a channel and are delivered to the other users with the translated text directly included.

Automatic translation works really well for 1-1 conversations or group channels with two main languages.

Let’s see how this works in practice:

A user sends a message and automatic translation is enabled

The language set for that user is used as source language (if not the source language will be automatically detected)

The message text is translated into the other language in used on the channel by its members

When using auto translation, it is recommended setting the language for all users and add them as channel members

Enabling automatic translation
Automatic translation is not enabled by default. You can enable it for your application via API or CLI from your backend. You can also enable auto translation on a channel basis.


JavaScript

Java

PHP

Python

Ruby

Go

C#

Unity

// enable auto-translation only for this channel
await channel.update({ auto_translation_enabled: true });
// ensure all messages are translated in english for this channel
await channel.update({
  auto_translation_enabled: true,
  auto_translation_language: "en",
});
// auto translate messages for all channels
await client.updateAppSettings({ auto_translation_enabled: true });
Set user language
In order for auto translation to work, you must set the user language or specify a destination language for the channel using the auto_translation_language field (see previous code example).


Kotlin

JavaScript

Java

PHP

Python

Ruby

Go

C#

Unity

Swift

// Backend SDK
// sets the user language
await client.connectUser({ id: "userId", language: "en" }, userToken);
// watch a channel
await client.channel("messaging", "melting-pot");
Messages are automatically translated from the user language that posts the message to the most common language in use by the other channel members.

Caveats and limits
Translation is only done for messages with up to 5,000 characters. Blowin’ In The Wind from Bob Dylan contains less than 1,000 characters

Error messages and commands are not translated (ie. /giphy hello)

When a message is updated, translations are recomputed automatically

Changing translation settings or user language have no effect on messages that are already translated

If there are three or more languages being used by channel members, auto-translate will default to the most common language used by the channel members. Therefore, this feature is best suited for groups with a maximum of two main languages.

A workaround to support more than two languages is to use the translateMessage endpoint to store translated messages for multiple languages, and render the appropriate translation depending on the current users language.

Available Languages
Language name	Language code
Afrikaans	af
Albanian	sq
Amharic	am
Arabic	ar
Azerbaijani	az
Bengali	bn
Bosnian	bs
Bulgarian	bg
Chinese (Simplified)	zh
Chinese (Traditional)	zh-TW
Croatian	hr
Czech	cs
Danish	da
Dari	fa-AF
Dutch	nl
English	en
Estonian	et
Finnish	fi
French	fr
French (Canada)	fr-CA
Georgian	ka
German	de
Greek	el
Haitian Creole	ht
Hausa	ha
Hebrew	he
Hindi	hi
Hungarian	hu
Indonesian	id
Italian	it
Japanese	ja
Korean	ko
Latvian	lv
Lithuanian	lt
Malay	ms
Norwegian	no
Persian	fa
Pashto	ps
Polish	pl
Portuguese	pt
Romanian	ro
Russian	ru
Serbian	sr
Slovak	sk
Slovenian	sl
Somali	so
Spanish	es
Spanish (Mexico)	es-MX
Swahili	sw
Swedish	sv
Tagalog	tl
Tamil	ta
Thai	th
Turkish	tr
Ukrainian	uk
Urdu	ur
Vietnamese	vi
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Restricted Message Delivery
Next
Pending Messages
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Pending Messages
Pending Messages
Pending Messages features lets you introduce asynchronous moderation on messages being sent on channel. To use this feature please get in touch with support so that we can enable it for your organisation.

Sending Pending Messages
Messages can be made pending by default by setting the channel config property mark_messages_pending to true.


Node

Python

PHP

Go

Ruby

Java

response = await client.updateChannelType("messaging", {
  mark_messages_pending: true,
});
You can also set the pending property on a message to mark it as pending on server side (this will override the channel configuration). Please note that this is only server-side feature .


JavaScript

Java

PHP

Ruby

Python

Go

const message = await channel.sendMessage(
  {
    text: "this is my pending message",
    user_id: "user-id",
  },
  {
    pending: true,
    pending_message_metadata: {
      my: "metadata",
    },
  },
);
Pending messages will only be visible to the user that sent them. They will not be query-able by other users.

Callbacks
When a pending message is either sent or deleted, the message and its associated pending message metadata are forwarded to your configured callback endpoint via HTTP(s). You may set up to two pending message hooks per application. Only the first commit to a pending message will succeed; any subsequent commit attempts will return an error, as the message is no longer pending. If multiple hooks specify a timeout_ms, the system will use the longest timeout value.

You can configure this callback using the dashboard or server-side SDKs.

Using the Dashboard
Go to the Stream Dashboard
Select your app
Navigate to your app’s settings until “Webhook & Event Configuration” section
Click on “Add Integration”
Add and configure pending message hook

Using Server-Side SDKs

JavaScript

Python

Ruby

PHP

Go

Java

C#

// Note: Any previously existing hooks not included in event_hooks array will be deleted.
// Get current settings first to preserve your existing configuration.
// STEP 1: Get current app settings to preserve existing hooks
const response = await client.getAppSettings();
console.log("Current event hooks:", response.event_hooks);
// STEP 2: Add pending message hook while preserving existing hooks
const existingHooks = response.event_hooks || [];
const newPendingMessageHook = {
  enabled: true,
  hook_type: "pending_message",
  webhook_url: "https://example.com/pending-messages",
  timeout_ms: 10000, // how long messages should stay pending before being deleted
  callback: {
    mode: "CALLBACK_MODE_REST",
  },
};
// STEP 3: Update with complete array including existing hooks
await client.updateAppSettings({
  event_hooks: [...existingHooks, newPendingMessageHook],
});
See the Multi-Event Hooks documentation for complete details.

Callback Request
For example, if your callback server url is https://example.com, we would send callbacks:

When pending message is sent
POST https://example.com/PassOnPendingMessage

When a pending message is deleted
POST https://https://example.com/DeletedPendingMessage

In both callbacks, the body of the POST request will be of the form:


JSON

{
  "message": {
    // the message object
  },
  "metadata": {
    // keys and values that you passed as pending_message_metadata
  },
  "request_info": {
    // request info of the request that sent the pending message. Example:
    /*
    "type": "client",
    "ip": "127.0.0.1",
    "user_agent": "Mozilla/5.0...",
    "sdk": "stream-chat-js",
    "ext": "additional-data"
    */
  }
}
Deleting pending messages
Pending messages can be deleted using the normal delete message endpoint. Users are only able to delete their own pending messages. The messages must be hard deleted. Soft deleting a pending message will return an error.

Updating pending messages
Pending messages cannot be updated.

Querying pending messages
A user can retrieve their own pending messages using the following endpoints:


Kotlin

Node

Java

PHP

Ruby

Python

Go

// To retrieve single message
client.getPendingMessage("pending_message_id").enqueue { result ->
    if (result is Result.Success) {
        val message: Message = result.value.message
        val metadata: Map<String, String> = result.value.metadata
    }
}
Query channels
Each channel that is returned from query channels will also have an array of pending_messages. These are pending messages that were sent to this channel, and belong to the user who made the query channels call. This array will contain a maximum of 100 messages and these will be the 100 most recently sent messages.


Kotlin

Node

Java

PHP

Ruby

Go

// Querying multiple channels
client.queryChannels(request).enqueue { result ->
    if (result is Result.Success) {
        val channels: List<Channel> = result.value
        // Pending messages in the first channel
        val pendingMessages: List<PendingMessage> = channels[0].pendingMessages
    }
}
// Querying single channel
val channelClient = client.channel("messaging", "channel_id")
channelClient.query(request).enqueue { result ->
    if (result is Result.Success) {
        val channel: Channel = result.value
        // Pending messages in the channel
        val pendingMessages: List<PendingMessage> = channel.pendingMessages
    }
}
Committing pending messages
Calling the commit message endpoint will promote a pending message into a normal message. This message will then be visible to other users and any events/push notifications associated with the message will be sent.

The commit message endpoint is server-side only.


Node

Java

PHP

Ruby

Python

Go

await serverClient.commitMessage(id);
If a message has been in the pending state longer than the timeout_ms defined for your app, then the pending message will be deleted. The default timeout for a pending message is 3 days.

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Translation
Next
Campaign API
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Campaign API
Campaign API
The Campaign API makes it easy to send a message or send an announcement to a large group of users and/or channels. You can personalize the message using templates. For small campaigns of less than 10,000 users, you can directly send the campaign. If you need to maintain larger segments of users or channels that’s also supported. The potential applications of this feature are virtually limitless, yet here are some specific examples:

The Campaign API runs with administrative privileges and does not validate permissions - any valid user ID can be used as the sender_id. Be sure to implement appropriate access controls in your application code.
Marketing Campaigns : Send promotional messages or announcements to a targeted audience.

Product Updates : Inform users about new features, bug fixes, or enhancements to your product.

Event Reminders: Send reminders about upcoming events, webinars, or conferences to registered attendees.

Customer Surveys : Engage with your user base by sending out surveys or feedback forms to gather feedback.

Announcements : Broadcast important company news, policy changes, or updates to stakeholders.

Campaign Scheduling : Plan and schedule campaigns in advance to ensure timely delivery and maximize impact

Under the hood, campaigns send messages to the specified target audience and do so on behalf of a designated user ( sender ). If there are no existing channels to deliver messages to the target users, campaigns can automatically create them. Additionally, campaigns might generate more events for creating channels and sending new messages. These events can be sent as In-App messages and/or Push Notifications to the end users, and as Webhook calls to your backend server.

The Campaigns API is designed for backend-to-backend interactions and is not intended for direct use by client-side applications.

By default we have rate limits in place to ensure that campaigns don’t cause stability issues. The throughput supports sending campaigns with tens of millions of messages. Be sure to reach out to support to collaborate with our team and raise your limits.

All paid plans include 3 times the procured MAU volume in message capacity. Ex: if you have a 100,000 MAU plan you can send 300,000 campaign messages each month. If you need to send more messages than this limit reach out to our sales team

Sending a Campaign
Here’s a basic example of how to send a campaign. Note that the sender_id can be any valid user ID since the Campaign API bypasses normal permission checks.

You can send the campaign immediately or schedule it to start at a later time. You can also stop the campaign at any time.


JavaScript

Python

const segmentId = '<segment-id>'; // segment_id is optional
// Create a dynamic user segment based on the filter provided.
// e.g., following segment will include all users created after 2020-01-01
const segment = client.segment('user', segmentId, {
  name: 'New App Users Segment (optional)',
  filter: {
    created_at: {
      $gte: '2020-01-01T00:00:00Z',
    }
  }
})
await segment.create();
const campaign_id = '<campaign-id>'; // campaign_id is optional
const campaign = client.campaign(campaign_id, {
  // Users targeted by following segment will receive the message
  segment_ids: [segmentId],
  // Alternatively, instead of segment_ids, you can also provide user_ids to send the message to specific users
  // user_ids: ['<user-id-1>', '<user-id-2>'],
  sender_id: '<user-id-of-sender>', // Mandatory
  // Optional, specifies whether to 'exclude' or 'include' the sender from the channel. Defaults to null.
  sender_mode: 'exclude',
  // Optional, controls the visibility of the new channels for the sender ('hidden' or 'archived'). Defaults to null
  sender_visibility: 'hidden',
  name: 'Campaign name', // Optional
  description: 'Campaign Description', // Optional
  message_template: {
    text: 'Hello {{receiver.name}}!', // Mandatory, message text template
    attachments: [], // Optional, message attachments
    poll_id: 'poll-id', // Optional, send a poll with message
    custom: { promotional: true }, // Optional, custom fields will be added to message object received by the receiver.
  },
  show_channels: true, // Optional, show hidden channels for receiver
  create_channels: true, // Optional, create channel between sender and receiver if not already present
  // channel_template is required if create_channels is true
  channel_template: {
    // Mandatory, channel type
    type: 'messaging',
    // Optional, template for channel id for channel creation
    // if not provided, channel id will be generated on server side
    id: '{{receiver.id}}-{{sender.id}}',
    // Optional, custom fields will be added to channel object
    custom: { promotional: true },
    // Optional, if provided (and multi tenancy is enabled), you can limit accessibility to the channel only to a team
    team: 'kansas-city-chiefs',
    // Optional, if provided following members will be added to each of the newly created channel
    // if not provided, only sender and receiver will be added to the channel
    // You can use this to add e.g., moderator or admin to each newly created channel
    members: ['user-id-1', 'user-id-2'],
    // Alternatively, you can use members_template to specify channel roles and custom data for members.
    // members and members_template cannot be used together.
    // members_template: [
    //   {
    //     user_id: 'user-id-1',
    //     channel_role: 'channel_moderator', // Optional
    //     custom: { key1: 'value1' }, // Optional
    //   },
    //   {
    //     user_id: 'user-id-2',
    //     channel_role: 'channel_moderator', // Optional
    //   },
    // ]
  }
})
await campaign.create();
// Start sending messages to targeted users
await campaign.start();
// Alternatively you can also schedule the campaign to start at a later time and stop at a specific time
await campaign.start({
  scheduledFor: new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString()
  stopAt: new Date(Date.now() + 72 * 60 * 60 * 1000).toISOString()
});
The campaign exposes methods to create, get, update, start, stop delete and query campaigns.


JavaScript

Python

await campaign.create(); // create a campaign based on data passed above
await campaign.get(); // check the status of the campaign
await campaign.update({
  segment_ids: ["a869fc0f-2e7e-4fe0-8651-775c892c1718"],
  sender_id: "Updated-user-id-of-sender", // mandatory
  sender_mode: "include", // optional
  sender_visibility: "archived", // optional
  name: "Updated name (optional)",
  message_template: {
    text: "Updated Hello {{receiver.name}}!",
  },
}); // updates the campaign data
// You can start a campaign immediately, which will start sending messages to the users in the segment(s) immediately.
await campaign.start();
// Or you can schedule a campaign to start at a later time.
await campaign.start({
  // start campaign in 48 hours
  scheduledFor: new Date(Date.now() + 48 * 60 * 60 * 1000).toISOString(), // optional, campaign will start running after this time
  // automatically stop the campaign after 72 hours
  stopAt: new Date(Date.now() + 72 * 60 * 60 * 1000).toISOString(), // optional, campaign will stop running after this time
});
await campaign.stop(); // stops the campaign
await campaign.delete(); // delete the campaign
const filter = {
  segments: { $in: ["<segment-id>"] },
};
const sort = [{ field: "created_at", direction: -1 }];
const options = {
  limit: 30,
  next: "<encoded_next>",
};
const result = client.queryCampaigns(filter, sort, options); // query campaigns
// result.campaigns is an array of campaigns
// result.next is a cursor for the next page of campaigns
Creating a Campaign
Here are the supported options for creating a campaign:

name	type	description	default	optional
id	string	Specify an ID for your campaign	-	✓
name	string	The name of the campaign	-	✓
description	string	The description for the campaign	-	✓
segment_ids	string	A list of segments to target. Max 25. Use either segment_ids or user_ids to target your campaign. The campaign will automatically remove duplicates if users are present in more than 1 segment.	-	✓
user_ids	string	A list of user ids to target. Max 10,000 users, for bigger campaigns create a user segment first. Use either user_ids or segment_ids to target your campaign.	-	✓
sender_id	string	The user id of the user that’s sending the campaign. Note: The sender_id is not checked against the permission system - any valid user ID can be used.	-	
sender_mode	string	Controls how the campaign sender is added to channels. Possible values:
- "exclude": Don’t add sender to any channels
- "include": Add sender to all channels (new and existing)
When parameter is omitted (default behavior): Add sender to new channels only.	-	✓
sender_visibility	string	Controls the visibility of the new channels for the sender when the sender is included as a member. Possible values:
- "hidden": New channels will be hidden for the sender
- "archived": New channels will be archived for the sender
When parameter is omitted (default behavior): All channels are visible.	-	✓
message_template	string	A message template	-	
show_channels	boolean	If true then hidden channels will be shown for receiver	false	✓
create_channels	boolean	If true then channels will be created if they don’t exist yet	false	✓
channel_template	string	The template to use when creating a channel	-	✓
skip_push	boolean	Do not send push notifications for events generated by this campaign, such as message.new or channel.created	false	✓
skip_webhook	boolean	Do not call webhooks for events generated by this campaign, such as message.new or channel.created	false	✓
Note that campaigns can only be sent once. If you want to repeate the same campaign you have to create a new campaign object with the same template and segment ids.

Message Template
The message template uses Django/Jinja style variables. So you can use {{ myvariable }} to customize the message. The following fields are available:

VarIABLE	Description
Sender	User object that’s sending this campaign
Receiver	The person receiving the message. This is only available in 1-1 channels, and not when sending to a group
Channel	The channel the message is being sent to
So for example you could use a template like: “Hi {{ receiver.name }} welcome to the community”. Messages sent by the campaign API will automatically contain the campaign_id custom field and will have type set to regular.


JSON

{
  "text": "{{ sender.name }} says hello!",
  "custom": {
   "campaign_data": {{ custom }},
  },
  "attachments": [{
   "type": "image", "url": "https://path/to/image.jpg"
  }],
  "poll_id": "poll-id",
}
Channel Template
Here’s an example channel template. It enables the campaign API to find the right channel for a recipient and sender.


JSON

{
  "type": "messaging", // channel type is required
  "id": "{{receiver.id}}-{{sender.id}}",
  "team": "kansas-city-chiefs", // optional, if provided (and multi tenancy is enabled), you can limit accessibility to the channel only to a team
  "custom": {
    // optionally add custom data to channels (only when creating)
  }
}
Querying Campaigns
You can query campaigns based on extensive set of filters and sort options


JavaScript

Python

// Query campaigns with which are scheduled or in progress
const filter = { status: { $in: ["scheduled", "in_progress"] } };
const sort = [{ field: "created_at", direction: -1 }];
const options = { limit: 10 };
// query first page
const { campaigns, next } = await client.queryCampaigns(filter, sort, options);
// query next page
const res = await client.queryCampaigns(filter, sort, { ...options, next });
Following code sample provides various examples of filters:


JavaScript

Python

const filterStatus = { status: { $in: ["scheduled", "in_progress"] } };
const filterID = { id: { $in: ["campaign_id_1", "campaign_id_2"] } };
const filterBySegments = {
  segments: { $in: ["segment_id_1", "segment_id_2"] },
};
const filterByName = { name: { $in: ["campaign_name_1", "campaign_name_2"] } };
const filterBySender = { sender_id: { $in: ["sender_1", "sender_2"] } };
const filterByCreated = { created_at: { $gte: "2021-01-01T00:00:00Z" } };
const filterByUpdated = { updated_at: { $gte: "2021-01-01T00:00:00Z" } };
Paginating Campaign Users
If you created a campaign targeting a specific list of user IDs, you can retrieve the targeted users using pagination. The Campaign API limits each response to 1,000 users. To access additional users beyond this limit, you can paginate using the limit and next parameters, as shown below.


JavaScript

Python

// Let's say you have a campaign with 2000 users
const campaign = client.campaign("<campaign-id>");
// Fetch camapgin with the first 1000 users
const res1 = await campaign.get({
  users: {
    limit: 1000,
  },
});
const firstPageUsers = res1.campaign.users;
// Fetch campaign with the next 1000 users
const res2 = await campaign.get({
  users: {
    limit: 1000, // 1000 is max allowed limit
    next: res1.users.next,
    // or use prev to get previous page
    prev: res1.users.prev,
  },
});
const secondPageUsers = res2.campaign.users;
Segments for Campaigns
Segments enable you to target large groups of users. You can either specify a large list of user ids, channel ids, or filters that search the user database. There is no limit on how many users you can have in a segment.

User Segments

JavaScript

Python

const type = <'user'|'channel'>; // mandatory
const id = "<segment_id>"; // optional
const data = {
	filter: {
		team:'commonteam'
	},
	name: 'segment_name',
	description: 'segment_description'
} // optional
const segment = client.segment(type, id, data)
You can create, update or delete segments. You can also add users to the segment. The above approach specified a filter to query the users. Alternatively you can also manually provide a list of user ids.


JavaScript

Python

const segmentType = "user"; // mandatory
const segmentId = "<segment_id>"; // optional
const data = {
	filter: {
		//...
	}
} // optional
let userSegment = client.segment(segmentType, segmentId, data);
await userSegment.create()
await userSegment.get()
await userSegment.addTargets(userIds); // a max of 10,000 users can be added in 1 API call
await userSegment.removeTargets(userIds); // no error if doesn't exits
await userSegment.targetExists(userId); // checks if target exists in the segment
await userSegment.queryTargets(
	{ "target_id": {"$gte": <user_id>} },
	[{ field: "target_id", direction: -1 }],
	{
	 limit: 10000,
	 next: '<encoded_next>', // or prev
	}
); // queries targets in the segment
	await userSegment.delete(); // deletes segment
The example below shows how to create a segment with all users :


JavaScript

Python

const data = {
  name: "everyone",
  all_users: true,
};
let userSegment = client.segment("user", data);
await userSegment.create();
User segment supports following options as part of data :

name	type	description	default	optional
name	string	Name for the segment	-	✓
description	string	Description of the segment	-	✓
filter	json	Filter criteria for target users of this segment	null	✓
all_users	boolean	If true, segment will target all the users of the app	false	✓
Channel Segments
You can also create segments of channels to target. If you target a channel the “receiver” message template variable will not be available.


JavaScript

Python

// note: channel template is not required for channel segment
let segmentType = "channel";
let segmentId = "segmentId";
let data = {
  name: "segment_name",
  description: "segment_description",
  filter: {
    team: "commonteam",
  },
};
let channelSegment = client.segment(segmentType, segmentId, data);
await channelSegment.create();
await channelSegment.get();
await channelSegment.addTargets(channelCids);
await channelSegment.removeTargets(channelCids);
await channelSegment.targetExists(channelCid);
await channelSegment.delete();
The example below shows how to create a segment which targets all the channels where sender is member of


JavaScript

Python

const data = {
  name: "All my existing chats",
  all_sender_channels: true,
};
let channelSegment = client.segment("channel", data);
await channelSegment.create();
Channel segment supports following options as part of the data :

name	type	description	default	optional
name	string	Name of the segment	-	✓
description	string	Description for the segment	-	✓
filter	json	Filter criteria for target channels of this segment	null	✓
all_sender_channels	boolean	If true, segment will target all the channels where sender is member of	false	✓
Getting Segment
For getting a specified segment you may use the following code snippet:


JavaScript

Python

const segment = client.segment(segmentType, segmentId);
const response = await segment.get();
The received response will contain the segment data:

name	type	description	default	optional
id	string	ID of the segment	-	
type	string	Type of the segment (“user” or “channel”)	-	
name	string	Name of the segment	""	
description	string	Description of the segment	""	
filter	object	Filter criteria for target users or channels of this segment	nil	
all_users	boolean	If true, then segment targets all the users of the app	false	
all_sender_channels	boolean	If true, then segment targets all the channels where sender is member of	false	
size	integer	Number of the targets for this segment	0	
created_at	string	Date when the segment was created	-	
updated_at	string	Date when the segment was update	-	
deleted_at	string	Date when the segment was deleted	-	✓
Please, take into account that:

Parameters filter, all_users and all_sender_channels are mutually exclusive.

The size is calculated asynchronously when either filter or all_users is set.

The size is calculated in place if you add targets manually using segment.addTargets(...) function

The size won’t be calculated at all if all_sender_channels is set to true. If you want the size to be calculated for the channel segment types, please provide the filter instead.

Sending a Campaign to Segments - Full example
The example below shows you how to create a segment and send a campaign to it

Create a segment for user’s in the USA

JavaScript

Python

const data = {
	name: 'People in the USA'
	filter: {
		country: 'USA'
	}
};
const segment = client.segment('user', data);
await segment.create();
Message the above segment
Remember that the Campaign API allows using any valid user ID as sender_id regardless of permissions. Make sure to validate in your application code that the requesting user has appropriate permissions to send campaigns on behalf of other users.

JavaScript

Python

const campaign = client.campaign({
  segment_ids: [segment.id],
  sender_id: "user-id-of-sender", // mandatory
  name: "Campaign name (optional)",
  description: "Optional description",
  message_template: {
    text: "Hi {{ receiver.name }} I'm {{ sender.name }}!",
  },
});
await campaign.create();
await campaign.start();
// Alternatively you can schedule the campaign to start at a later time.
// Also you can stop the campaign at a specific time. E.g.,
await campaign.start({
  scheduledFor: "2021-12-31T23:59:59Z",
  stopAt: "2022-01-01T23:59:59Z",
});
Check the status of the campaign

JavaScript

Python

const res = await campaign.get();
console.log(res.campaign.status); // "draft" | "scheduled" | "stopped" | "completed" | "in_progress"
Campaign status have following possible values:

draft - Campaign has been created but not scheduled

scheduled - Campaign has been scheduled

stopped - Campaign has been stopped manually or using stop_at option

completed - Campaign has succesfully completed

in_progress - Campaign is running at the moment

Sending campaigns is fast but not realtime. It can take several minutes for your campaign to complete sending. A campaign with 60,000 users typically takes ~1 minute to send.

Campaign Stats
The campaign API returns stats when you call campaign.get.


JavaScript

Python

// await campaign.get()
{
 "id": "...",
 "stats": {
  "started_at": "2021-02-01 00:00:00",
  "completed_at": "2024-23-02 00:00:00",
  "messages_sent": 1000,
  "channels_created": 10,
  "stats_progress": 0.97,
  "stats_users_sent": 1000, // number of users the campaign message was sent to
  "stats_users_read": 567   // number of users who read the campaign message
 }
}
Webhooks
Your app will often want to know when a campaign API starts or stops. Your server hooks will receive an event when the campaign starts and another when the campaign is completed.

Both events include the full campaign object with its status and stats.


JSON

{
  "type": "campaign.started",
  "campaign": {
    "status": "running",
    "stats": {...},
    ...
  },
  "created_at": "2024-23-02 00:00:00"
}
{
  "type": "campaign.completed",
  "campaign": {
    "status": "completed",
    "stats": {...},
    ...
  },
  "created_at": "2024-23-02 00:00:00"
}
Updating a large Segment
client.querySegments allows you to paginate over a large segment with up to 10,000 results per page.


JavaScript

Python

const filter = {
  name: "<name>",
};
const sort = [{ field: "created_at", direction: -1 }];
const options = {
  limit: 30,
  next: "<encoded_next>",
};
let response = await client.querySegments(filter, sort, options);
The list of users is sorted by ID ASC. This means that you can easily compare it to your internal list of users in this segment, and call segment.addTargets/addTargets as needed.

Page updated Feb 20th 5:42

Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Pending Messages
Next
Message Delivery & Read status
© Getstream.io, Inc. All Rights Reserved.
Chat Messaging
/
Docs
/
React Native
/
Message Delivery & Read status
Message Delivery & Read status
Sent messages go through multiple states reflecting the receiving side’s interaction with the messages:

sent - The message has reached the Stream server successfully after it was created from the client device. The WebSocket message.new event is sent to the client to confirm the message creation.
delivered - Requires the client device to confirm the delivery (e.g. upon receiving message.new event or querying the channels directly). The message delivery is confirmed to the message author and other channel members via the message.delivered WS event. This information is disabled by default, but can be enabled through the channel type dashboard.
read - Requires the client to confirm the channel has been read when opening the channel. This is confirmed to the channel members via message.read WS event. It is not possible to mark a specific message in a channel as read, only the whole channel.
Enabling Delivery Receipts Tracking
Please contact our support team to enable message delivery tracking in your app.

The Android SDK requires the offline plugin for this feature to function correctly and efficiently. This avoids extra API calls to retrieve message and channel data.

It is possible to control the message delivery tracking on two levels:

Channel type (for all members)
Message delivery tracking can be enabled in the channel type configuration.


JavaScript

// when creating a channel
await client.createChannelType("targetChannelType", { delivery_events: true });
// updating an existing channel
await client.updateChannelType("targetChannelType", { delivery_events: true });
The feature can be enabled in dashboard as well (channel type configuration).

User
On the user level the configuration can be done programmatically only. We can control the delivery confirmation reporting for a given user as follows:


JavaScript

Swift

Kotlin

await client.upsertUser({
  id: "user-id",
  privacy_settings: {
    delivery_receipts: {
      enabled: false, // do not report even though the channel read events are enabled
    },
  },
});
If privacy_settings.delivery_receipts.enabled is set to false, then the message delivery state of this user will not be exposed to others. Additionally, the related event message.delivered, will not be delivered to others when this user confirms the delivery messages.

Enabling Read Receipts Tracking
It is possible to control the message read status tracking on two levels:

Channel type (for all members)
Message read status tracking can be enabled in a channel type configuration.


JavaScript

// when creating a channel
await client.createChannelType("targetChannelType", { read_events: true });
// updating an existing channel
await client.updateChannelType("targetChannelType", { read_events: true });
The feature can be enabled in dashboard as well (channel type configuration).

User
On the user level the configuration can be done programmatically only.


JavaScript

Swift

Kotlin

await client.upsertUser({
  id: "user-id",
  privacy_settings: {
    read_receipts: {
      enabled: false, // do not report even though the channel read events are enabled
    },
  },
});
If privacy_settings.read_receipts.enabled is set to false, then the read state of this user will not be exposed to others. Additionally, the related events, such as message.read and notification.mark_read, will not be delivered to others when this user reads messages.

Marking Channel Messages as Delivered
Message delivery tracking is currently supported only for the channel message list, not thread replies.

The SDK will automatically handle the process of reporting message delivery from the user receiving the message to the server and from there to the other users. The SDK takes care of request throttling, duplicate request prevention and synchronization rules between the message receipt states.

Marking a Channel as Read
We can mark all messages in a channel as read client-side as follows:


Kotlin

JavaScript

Dart

Swift

Unreal

Java

Unity

await channel.markRead();
Or from server-side by providing a user id:


JavaScript

PHP

await channel.markRead({ user_id: "foo" });
Marking a Message as Unread
Users can have unread messages in a channel because new messages arrived while they were away, or because they explicitly marked a message as unread. Marking a message unread sets a new last read message reference. The message delivery reference does not change. You can mark a message as unread from client-side:


Kotlin

JavaScript

Swift

await channel.markUnread({ message_id: "<message_id>" });
To mark an entire thread as unread you may pass thread_id instead.


await channel.markUnread({ thread_id: "<thread_id>" })
To mark all messages after a timestamp as unread you may pass message_timestamp.


await channel.markUnread({ message_timestamp: "<message_timestamp>" })
Or from server-side by providing a user id:


JavaScript

await channel.markUnread({ message_id: "<message_id>", user_id: "<user_id>" });
For performance reasons it’s only possible to mark any of the last 100 messages of the channel as unread.

Read state
When you retrieve a channel from the API (e.g. using query channels), the read state for members is included in the response (up to 100 members, ordered by the most recent added, the current user’s read state is always included).

The read state includes the following fields:

last_read - the timestamp when the channel has been marked read the last time by the given user
user - user whose read state is being described
And optionally includes:

last_read_message_id- the last message reported as read in the channel by the user
unread_messages - the number of unread messages for a given user in the channel
last_delivered_at - the timestamp when the channel messages have been reported as delivered the last time by the given user
last_delivered_message_id - the last message reported as delivered in the channel by the user
The members read states can be retrieved by query the channel data:


Kotlin

JavaScript

Swift

const channel = client.channel("messaging", "test");
await channel.watch();
console.log(channel.state.read["<user id>"]);
{
  last_read: "2024-02-09T12:23:46.361362996Z";
  last_read_message_id: "sara-e9c0d141-b109-4116-baec-e76966ae712e";
  unread_messages: 3;
}
The last read message id is updated in the following events:

message.read

notification.mark_read

notification.mark_unread


Kotlin

JavaScript

Swift

const channel = client.channel("messaging", "test");
await channel.watch();
// Any member read the channel
channel.on("message.read", (event) => {
  console.log(event.last_read_message_id);
  // Unread messages: 0
});
// Connected user read the channel
channel.on("notification.message_read", (event) => {
  console.log(event.last_read_message_id);
  // Unread messages: 0
});
// Connected user marked a message as unread
channel.on("notification.message_unread", (event) => {
  console.log(event.last_read_message_id);
  // Unread messages
  console.log(event.unread_messages);
});
The last delivered message id is updated in the following events:

message.delivered
Jump to last read message
This is how you can jump to the last read message inside a given channel:


JavaScript

Swift

const channel = client.channel("messaging", "test");
await channel.watch();
const lastReadMessageId = channel.state.read["<user id>"];
await channel.state.loadMessageIntoState(lastReadMessageId);
console.log(channel.state.messages);
Message Delivery Push Notifications
By default, when a user receives a push notification for a new message, and the app is not active, the message is not marked as delivered. You can change this behavior by calling the mark delivered endpoint when a push notification is received for a new message. For this, you will need to customize the push notifications depending on the platform.

iOS Custom Push Notifications
Android Custom Push Notifications

Swift

Kotlin

// By using the `ChatRemoteNotificationHandler` in the NotificationService extension
// you can use the provided `markMessageDelivered` method to mark the message as delivered.
let chatHandler = ChatRemoteNotificationHandler(client: client, content: content)
let chatNotification = chatHandler.handleNotification { chatContent in
    switch chatContent {
    case let .message(messageNotification):
        switch messageNotification.type {
        case .messageNew:
            // Mark the message as delivered
            if let channel = messageNotification.channel {
                chatHandler.markMessageAsDelivered(messageNotification.message, for: channel)
            }
        default:
            break
        }
    }
}
Did you find this page helpful?
It was helpful
It was not helpful
I have feedback
Previous
Campaign API
Next
Polls API
© Getstream.io, Inc. All Rights Reserved.
